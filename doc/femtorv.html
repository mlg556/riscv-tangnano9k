<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FemtoRV</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">FemtoRV</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#from-blinker-to-risc-v"
id="toc-from-blinker-to-risc-v">From Blinker to RISC-V</a>
<ul>
<li><a href="#about-this-tutorial" id="toc-about-this-tutorial">About
this tutorial</a></li>
<li><a href="#introduction-and-references-on-processor-design"
id="toc-introduction-and-references-on-processor-design">Introduction
and references on processor design</a></li>
<li><a href="#prerequisites"
id="toc-prerequisites">Prerequisites:</a></li>
<li><a href="#step-1-your-first-blinky"
id="toc-step-1-your-first-blinky">Step 1: your first blinky</a></li>
<li><a href="#step-2-slower-blinky" id="toc-step-2-slower-blinky">Step
2: slower blinky</a></li>
<li><a href="#step-3-a-blinker-that-loads-leds-patterns-from-rom"
id="toc-step-3-a-blinker-that-loads-leds-patterns-from-rom">Step 3: a
blinker that loads LEDs patterns from ROM</a></li>
<li><a href="#the-risc-v-instruction-set-architecture"
id="toc-the-risc-v-instruction-set-architecture">The RISC-V instruction
set architecture</a></li>
<li><a href="#step-4-the-instruction-decoder"
id="toc-step-4-the-instruction-decoder">Step 4: the instruction
decoder</a></li>
<li><a href="#sidebar-the-elegance-of-risc-v"
id="toc-sidebar-the-elegance-of-risc-v">Sidebar: the elegance of
RISC-V</a></li>
<li><a href="#step-5-the-register-bank-and-the-state-machine"
id="toc-step-5-the-register-bank-and-the-state-machine">Step 5: The
register bank and the state machine</a></li>
<li><a href="#step-6-the-alu" id="toc-step-6-the-alu">Step 6: the
ALU</a></li>
<li><a href="#step-7-using-the-verilog-assembler"
id="toc-step-7-using-the-verilog-assembler">Step 7: using the VERILOG
assembler</a></li>
<li><a href="#step-8-jumps" id="toc-step-8-jumps">Step 8: jumps</a></li>
<li><a href="#step-9-branches" id="toc-step-9-branches">Step 9:
Branches</a></li>
<li><a href="#step-10-lui-and-auipc" id="toc-step-10-lui-and-auipc">Step
10: LUI and AUIPC</a></li>
<li><a href="#step-11-memory-in-a-separate-module"
id="toc-step-11-memory-in-a-separate-module">Step 11: Memory in a
separate module</a></li>
<li><a href="#step-12-size-optimization-the-incredible-shrinking-core."
id="toc-step-12-size-optimization-the-incredible-shrinking-core.">Step
12: Size optimization: the Incredible Shrinking Core.</a></li>
<li><a
href="#step-13-subroutines-version-1-using-plain-risc-v-instructions"
id="toc-step-13-subroutines-version-1-using-plain-risc-v-instructions">Step
13: subroutines (version 1, using plain RISC-V instructions)</a></li>
<li><a
href="#step-14-subroutines-version-2-using-risc-v-abi-and-pseudo-instructions"
id="toc-step-14-subroutines-version-2-using-risc-v-abi-and-pseudo-instructions">Step
14: subroutines (version 2, using RISC-V ABI and
pseudo-instructions)</a></li>
<li><a href="#step-15-load" id="toc-step-15-load">Step 15: Load</a></li>
<li><a href="#step-16-store" id="toc-step-16-store">Step 16:
Store</a></li>
<li><a
href="#step-17-memory-mapped-device---lets-do-much-more-than-a-blinky"
id="toc-step-17-memory-mapped-device---lets-do-much-more-than-a-blinky">Step
17: Memory-mapped device - let’s do (much) more than a blinky !</a></li>
<li><a href="#step-18-computing-the-mandelbrot-set"
id="toc-step-18-computing-the-mandelbrot-set">Step 18: Computing the
Mandelbrot set</a></li>
<li><a href="#step-19-faster-simulation-with-verilator"
id="toc-step-19-faster-simulation-with-verilator">Step 19: Faster
simulation with Verilator</a></li>
<li><a
href="#step-20-using-the-gnu-toolchain-to-compile-programs---assembly"
id="toc-step-20-using-the-gnu-toolchain-to-compile-programs---assembly">Step
20: Using the GNU toolchain to compile programs - assembly</a></li>
<li><a href="#step-21-using-the-gnu-toolchain-to-compile-programs---c"
id="toc-step-21-using-the-gnu-toolchain-to-compile-programs---c">Step
21: Using the GNU toolchain to compile programs - C</a></li>
<li><a href="#step-22-storing-data-can-i-have-more-than-6-kb-of-memory"
id="toc-step-22-storing-data-can-i-have-more-than-6-kb-of-memory">Step
22: Storing data: can I have more than 6 kB of memory ?</a></li>
<li><a href="#step-23-running-programs-from-spi-flash-first-steps"
id="toc-step-23-running-programs-from-spi-flash-first-steps">Step 23:
running programs from SPI Flash, first steps</a></li>
<li><a
href="#step-24-running-programs-from-spi-flash-a-better-linker-script"
id="toc-step-24-running-programs-from-spi-flash-a-better-linker-script">Step
24: running programs from SPI Flash, a better linker script</a></li>
<li><a href="#next-tutorial" id="toc-next-tutorial">Next
tutorial</a></li>
<li><a href="#files-for-all-the-steps"
id="toc-files-for-all-the-steps">Files for all the steps</a></li>
</ul></li>
</ul>
</nav>
<style>
body { min-width: 70% !important; }
</style>
<h1 id="from-blinker-to-risc-v">From Blinker to RISC-V</h1>
<p>This tutorial is a progressive journey from a simple blinky design to
a RISC-V core.</p>
<p>It works with the following boards: - IceStick - IceBreaker - ULX3S -
ARTY</p>
<p>If you do not have a board, you can run everything in simulation (but
it is not as fun).</p>
<h2 id="about-this-tutorial">About this tutorial</h2>
<ul>
<li>it is a progressive introduction, changing only one thing at a time.
It is a curated version of my logbook when I learnt these notions
(2020-2022). I also tryed to keep track of all the dead ends I explored
and traps that caught me, they are often indicated as side remarks and
notes;</li>
<li>I try to keep hardware requirement as minimal as possible. With the
tiniest FPGA (IceStick Ice40HX1K) you can do the first episode of the
tutorial and transform it into a fully functional RV32I microcontroller
that can execute compiled C code.</li>
<li>in the end, the obtained processor is not the most efficient, but it
is not a toy: it can execute any program. To anwser the question you may
ask, yes, it <a
href="https://github.com/BrunoLevy/learn-fpga/tree/master/LiteX/software/Doom">runs
DOOM</a>! (but not on an IceStick, you will need a larger FPGA). It
works with the help of LiteX that has a nice SDRAM controller, because
Doom needs some RAM;</li>
<li>the tutorial is both about hardware and software: you will learn how
to compile programs in assembly and in C for your core;</li>
<li>I try to make all example programs fun and interesting while
reasonably short. The bundled demo programs include:
<ul>
<li>mandelbrot set in assembly and in C</li>
<li>rotozoom graphic effect</li>
<li>drawing filled polygons</li>
<li>raytracing These graphic program are all displayed in text mode on
the terminal, using ANSI escape sequences (yes, this makes BIG pixels).
For more fun, it is also possible to use a small OLED display instead
(will add instructions for that in the future).</li>
</ul></li>
<li><a href="PIPELINE.md">Episode II</a> is a WIP on pipelining, that
I’m currently trying to understand (and writing a tutorial about
something is a good way of making sure you understand it !).</li>
<li>This tutorial is in VERILOG. It is currently being ported into other
HDLs
<ul>
<li><a
href="https://github.com/bl0x/learn-fpga-amaranth">Amaranth/nMigen
version</a> by <span class="citation"
data-cites="bl0x">@bl0x</span></li>
<li>TODO: Silice version</li>
<li>TODO: SpinalHDL version</li>
</ul></li>
</ul>
<h2 id="introduction-and-references-on-processor-design">Introduction
and references on processor design</h2>
<p>To understand processor design, the first thing that I have read was
<a
href="https://stackoverflow.com/questions/51592244/implementation-of-simple-microprocessor-using-verilog/51621153#51621153">this
answer</a> on Stackoverflow, that I found inspiring. There is also <a
href="http://www.fpgacpu.org/papers/xsoc-series-drafts.pdf">this
article</a> suggested by <span class="citation"
data-cites="mithro">@mithro</span>. For a complete course, I highly
recommend <a href="http://web.mit.edu/6.111/www/f2016/">this one from
the MIT</a>, it also gives the principles for going much further than
what I’ve done here (pipelines etc…).</p>
<p>For Verilog basics and syntax, I read <em>Verilog by example by
Blaine C. Readler</em>, it is also short and to the point.</p>
<p>There are two nice things with the Stackoverflow answer: - it goes to
the essential, and keeps nothing else than what’s essential - the taken
example is a RISC processor, that shares several similarities with
RISC-V (except that it has status flags, that RISC-V does not have).</p>
<p>What we learn there is that there will be a <em>register file</em>,
that stores the so-called <em>general-purpose</em> registers. By
general-purpose, we mean that each time an instruction reads a register,
it can be any of them, and each time an instruction writes a register,
it can be any of them, unlike the x86 (CISC) that has
<em>specialized</em> registers. To implement the most general
instruction (<code>register &lt;- register OP register</code>), the
register file will read two registers at each cycle, and optionally
write-back one.</p>
<p>There will be an <em>ALU</em>, that will compute an operation on two
values.</p>
<p>There will be also a <em>decoder</em>, that will generate all
required internal signals from the bit pattern of the current
instruction.</p>
<p>If you want to design a RISC-V processor on your own, I recommend you
take a deep look at <a
href="https://stackoverflow.com/questions/51592244/implementation-of-simple-microprocessor-using-verilog/51621153#51621153">the
Stackoverflow answer</a>, and do some schematics on your own to have all
the general ideas in mind before going further… or you can choose to
directly jump into this tutorial, one step at a time. It will gently
take you from the most trivial Blinky design to a fully functional
RISC-V core.</p>
<h2 id="prerequisites">Prerequisites:</h2>
<p>First step is cloning the learn-fpga repository:</p>
<pre><code>$ git clone https://github.com/BrunoLevy/learn-fpga.git</code></pre>
<p>Before starting, you will need to install the following softwares: -
iverilog/icarus (simulation)</p>
<pre><code>  $ sudo apt-get install iverilog</code></pre>
<ul>
<li>yosys/nextpnr, the toolchain for your board. See <a
href="../toolchain.md">this link</a>.</li>
</ul>
<p>Note that iverilog/icarus is sufficient to run and play with all the
steps of the tutorial, but the experience is not the same. I highly
recommend to run each step on a real device. The feeling and excitation
of your own processor running some code for the first time is not of the
same magnitude when you are doing simulation !!!</p>
<h2 id="step-1-your-first-blinky">Step 1: your first blinky</h2>
<p>Let us start and create our first blinky ! Our blinky is implemented
as a VERILOG module, connected to inputs and outputs, as follows (<a
href="step1.v">step1.v</a>):</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">module</span> SOC <span class="op">(</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>       <span class="dt">input</span>  CLK<span class="op">,</span>        </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>       <span class="dt">input</span>  RESET<span class="op">,</span>      </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>       <span class="dt">output</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> LEDS<span class="op">,</span> </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>       <span class="dt">input</span>  RXD<span class="op">,</span>        </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>       <span class="dt">output</span> TXD         </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> CLK<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>      count <span class="op">&lt;=</span> count <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> LEDS <span class="op">=</span> count<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> TXD  <span class="op">=</span> <span class="bn">1&#39;b0</span><span class="op">;</span> <span class="co">// not used for now</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>   <span class="kw">endmodule</span></span></code></pre></div>
<p>We call it SOC (System On Chip), which is a big name for a blinky,
but that’s what our blinky will be morphed into after all the steps of
this tutorial. Our SOC is connected to the following signals:</p>
<ul>
<li><code>CLK</code> (input) is the system clock.</li>
<li><code>LEDS</code> (output) is connected to the 5 LEDs of the
board.</li>
<li><code>RESET</code> (input) is a reset button. You’ll say that the
IceStick has no button, but in fact … (we’ll talk about that later)</li>
<li><code>RXD</code> and <code>TXD</code> (input,output) connected to
the FTDI chip that emulates a serial port through USB. We’ll also talk
about that later.</li>
</ul>
<p>You can synthesize and send the bitstream to the device as
follows:</p>
<pre><code>$ BOARDS/run_xxx.sh step1.v</code></pre>
<p>where <code>xxx</code> corresponds to your board.</p>
<p>The five leds will light on… but they are not blinking. Why is this
so ? In fact they are blinking, but it is too fast for you to
distinguish anything.</p>
<p>To see something, it is possible to use simulation. To use
simulation, we write a new VERILOG file <a
href="bench_iverilog.v">bench_iverilog.v</a>, with a module
<code>bench</code> that encapsulates our <code>SOC</code>:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> bench<span class="op">();</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> CLK<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> RESET <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> LEDS<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span>  RXD <span class="op">=</span> <span class="bn">1&#39;b0</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> TXD<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>   SOC uut<span class="op">(</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>     .CLK<span class="op">(</span>CLK<span class="op">),</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>     .RESET<span class="op">(</span>RESET<span class="op">),</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>     .LEDS<span class="op">(</span>LEDS<span class="op">),</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>     .RXD<span class="op">(</span>RXD<span class="op">),</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>     .TXD<span class="op">(</span>TXD<span class="op">)</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span><span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> prev_LEDS <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>      CLK <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">forever</span> <span class="kw">begin</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>     <span class="bn">#1</span> CLK <span class="op">=</span> <span class="op">~</span>CLK<span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>     <span class="kw">if</span><span class="op">(</span>LEDS <span class="op">!=</span> prev_LEDS<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;LEDS = %b&quot;</span><span class="op">,</span>LEDS<span class="op">);</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>     <span class="kw">end</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>     prev_LEDS <span class="op">&lt;=</span> LEDS<span class="op">;</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span>   </span></code></pre></div>
<p>The module <code>bench</code> drives all the signals of our
<code>SOC</code> (called <code>uut</code> here for “unit under test”).
The <code>forever</code> loop wiggles the <code>CLK</code> signal and
displays the status of the LEDs whenever it changes.</p>
<p>Now we can start the simulation:</p>
<pre><code>  $ iverilog -DBENCH -DBOARD_FREQ=10 bench_iverilog.v step1.v
  $ vvp a.out</code></pre>
<p>… but that’s a lot to remember, so I created a script for that,
you’ll prefer to do:</p>
<pre><code>  $ ./run.sh step1.v</code></pre>
<p>You will see the LEDs counting. Simulation is precious, it lets you
insert “print” statements (<code>$display</code>) in your VERILOG code,
which is not directly possible when you run on the device !</p>
<p>To exit the simulation:</p>
<pre><code>  &lt;ctrl&gt;&lt;c&gt;
  finish</code></pre>
<p><em>Note: I developped the first version of femtorv completely on
device, using only the LEDs to debug because I did not know how to use
simulation, don’t do that, it’s stupid !</em></p>
<p><strong>Try this</strong> How would you modify <code>step1.v</code>
to slow it down sufficiently for one to see the LEDs blinking ?</p>
<p><strong>Try this</strong> Can you implement a “Knight driver”-like
blinking pattern instead of counting ?</p>
<h2 id="step-2-slower-blinky">Step 2: slower blinky</h2>
<p>You probably got it right: the blinky can be slowed-down either by
counting on a larger number of bits (and wiring the most significant
bits to the leds), or inserting a “clock divider” (also called a
“gearbox”) that counts on a large number of bits (and driving the
counter with its most significant bit). The second solution is
interesting, because you do not need to modify your design, you just
insert the clock divider between the <code>CLK</code> signal of the
board and your design. Then, even on the device you can distinguish what
happens with the LEDs.</p>
<p>To do that, I created a <code>Clockworks</code> module in <a
href="clockworks.v">clockworks.v</a>, that contains the gearbox and a
mechanism related with the <code>RESET</code> signal (that I’ll talk
about later). <code>Clockworks</code> is implemented as follows:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Clockworks </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>  CLK<span class="op">,</span>   <span class="co">// clock pin of the board</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>  RESET<span class="op">,</span> <span class="co">// reset pin of the board</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">output</span> clk<span class="op">,</span>   <span class="co">// (optionally divided) clock for the design.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">output</span> resetn <span class="co">// (optionally timed) negative reset for the design (more on this later)</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">parameter</span> SLOW<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span>SLOW<span class="op">:</span><span class="dv">0</span><span class="op">]</span> slow_CLK <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> CLK<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>      slow_CLK <span class="op">&lt;=</span> slow_CLK <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> clk <span class="op">=</span> slow_CLK<span class="op">[</span>SLOW<span class="op">];</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>This divides clock frequency by <code>2^SLOW</code>.</p>
<p>The <code>Clockworks</code> module is then inserted between the
<code>CLK</code> signal of the board and the design, using an internal
<code>clk</code> signal, as follows, in <a
href="step2.v">step2.v</a>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`include </span><span class="fl">&quot;clockworks.v&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> SOC <span class="op">(</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>  CLK<span class="op">,</span>        <span class="co">// system clock </span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>  RESET<span class="op">,</span>      <span class="co">// reset button</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> LEDS<span class="op">,</span> <span class="co">// system LEDs</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>  RXD<span class="op">,</span>        <span class="co">// UART receive</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> TXD         <span class="co">// UART transmit</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> clk<span class="op">;</span>    <span class="co">// internal clock</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> resetn<span class="op">;</span> <span class="co">// internal reset signal, goes low on reset</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>   <span class="co">// A blinker that counts on 5 bits, wired to the 5 LEDs</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      count <span class="op">&lt;=</span> <span class="op">!</span>resetn <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> count <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Clock gearbox (to let you see what happens)</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>   <span class="co">// and reset circuitry (to workaround an</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>   <span class="co">// initialization problem with Ice40)</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>   Clockworks #<span class="op">(</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>     .SLOW<span class="op">(</span><span class="dv">21</span><span class="op">)</span> <span class="co">// Divide clock frequency by 2^21</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>   <span class="op">)</span>CW<span class="op">(</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>     .CLK<span class="op">(</span>CLK<span class="op">),</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>     .RESET<span class="op">(</span>RESET<span class="op">),</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>     .clk<span class="op">(</span>clk<span class="op">),</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>     .resetn<span class="op">(</span>resetn<span class="op">)</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> LEDS <span class="op">=</span> count<span class="op">;</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> TXD  <span class="op">=</span> <span class="bn">1&#39;b0</span><span class="op">;</span> <span class="co">// not used for now   </span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>It also handles the <code>RESET</code> signal.</p>
<p>Now you can try it on simulation:</p>
<pre><code>  $ ./run.sh step2.v</code></pre>
<p>As you can see, the counter is now much slower. Try it also on
device:</p>
<pre><code>  $ BOARDS/run_xxx.sh step2.v</code></pre>
<p>Yes, now we can see clearly what happens ! And what about the
<code>RESET</code> button ? The IceStick has no button. In fact it has
one !</p>
<p><img src="IceStick_RESET.jpg" /></p>
<p>Press a finger on the circled region of the image (around pin
47).</p>
<p><strong>Try this</strong> Knight-driver mode, and <code>RESET</code>
toggles direction.</p>
<p>If you take a look at <a href="clockworks.v">clockworks.v</a>, you
will see it can also create a <code>PLL</code>, it is a component that
can be used to generate <em>faster</em> clocks. For instance, the
IceStick has a 12 MHz system clock, but the core that we will generate
will run at 45 MHz. We will see that later.</p>
<h2 id="step-3-a-blinker-that-loads-leds-patterns-from-rom">Step 3: a
blinker that loads LEDs patterns from ROM</h2>
<p>Now we got all the tools that we need, so let’s see how to transform
this blinker into a fully-functional RISC-V processor. This goal seems
to be far far away, but the processor we will have created at step 16 is
not longer than 200 lines of VERILOG ! I was amazed to discover that it
is that simple to create a processor. OK, let us go there one step at a
time.</p>
<p>We know already that a processor has a memory, and fetches
instructions from there, in a sequential manner most of the time (except
when there are jumps and branches). Let us start with something similar,
but much simpler: a pre-programmed christmas tinsel, that loads the LEDs
pattern from a memory (see <a href="step3.v">step3.v</a>). Our tinsel
has a memory with the patterns:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> MEM <span class="op">[</span><span class="dv">0</span><span class="op">:</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>       MEM<span class="op">[</span><span class="dv">0</span><span class="op">]</span>  <span class="op">=</span> <span class="bn">5&#39;b00000</span><span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>       MEM<span class="op">[</span><span class="dv">1</span><span class="op">]</span>  <span class="op">=</span> <span class="bn">5&#39;b00001</span><span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>       MEM<span class="op">[</span><span class="dv">2</span><span class="op">]</span>  <span class="op">=</span> <span class="bn">5&#39;b00010</span><span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>       MEM<span class="op">[</span><span class="dv">3</span><span class="op">]</span>  <span class="op">=</span> <span class="bn">5&#39;b00100</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>       ...</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>       MEM<span class="op">[</span><span class="dv">19</span><span class="op">]</span> <span class="op">=</span> <span class="bn">5&#39;b10000</span><span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>       MEM<span class="op">[</span><span class="dv">20</span><span class="op">]</span> <span class="op">=</span> <span class="bn">5&#39;b00000</span><span class="op">;</span>       </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p><em>Note that what’s in the initial block does not generate any
circuitry when synthesized, it is directly translated into the
initialization data for the BRAMs of the FPGA.</em></p>
<p>We will also have a “program counter” <code>PC</code> incremented at
each clock, and a mechanism to fetch <code>MEM</code> contents indexed
by <code>PC</code>:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> PC <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> leds <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      leds <span class="op">&lt;=</span> MEM<span class="op">[</span>PC<span class="op">];</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>      PC <span class="op">&lt;=</span> <span class="op">(!</span>resetn <span class="op">||</span> PC<span class="op">==</span><span class="dv">20</span><span class="op">)</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="op">(</span>PC<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p><em>Note the test <code>PC==20</code> to make it cycle.</em></p>
<p>Now try it with simulation and on device.</p>
<p><strong>Try this</strong> create several blinking modes, and switch
between modes using <code>RESET</code>.</p>
<h2 id="the-risc-v-instruction-set-architecture">The RISC-V instruction
set architecture</h2>
<p>An important source of information is of course the <a
href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V
reference manual</a>. There you learn that there are several flavors of
the RISC-V standard. Let us start from the simplest one (RV32I, that is,
32 bits base integer instruction set). Then we will see how to add
things, one thing at a time. This is a very nice feature of RISC-V,
since the instruction set is <em>modular</em>, you can start with a very
small self-contained kernel, and this kernel will be compliant with the
norm. This means standard tools (compiler, assembler, linker) will be
able to generate code for this kernel. Then I started reading Chapter 2
(page 13 to page 30). Seeing also the table page 130, there are in fact
only 11 different instrutions ! (I say for instance that an AND, an OR,
an ADD … are the same instruction, the operation is just an additional
parameter). Now we just try to have an idea of the overall picture, no
need to dive into the details for now. Let’s take a global look at these
11 instructions:</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 42%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th>instruction</th>
<th>description</th>
<th>algo</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>branch</td>
<td>conditional jump, 6 variants</td>
<td><code>if(reg OP reg) PC&lt;-PC+imm</code></td>
</tr>
<tr class="even">
<td>ALU reg</td>
<td>Three-registers ALU ops, 10 variants</td>
<td><code>reg &lt;- reg OP reg</code></td>
</tr>
<tr class="odd">
<td>ALU imm</td>
<td>Two-registers ALU ops, 9 variants</td>
<td><code>reg &lt;- reg OP imm</code></td>
</tr>
<tr class="even">
<td>load</td>
<td>Memory-to-register, 5 variants</td>
<td><code>reg &lt;- mem[reg + imm]</code></td>
</tr>
<tr class="odd">
<td>store</td>
<td>Register-to-memory, 3 variants</td>
<td><code>mem[reg+imm] &lt;- reg</code></td>
</tr>
<tr class="even">
<td><code>LUI</code></td>
<td>load upper immediate</td>
<td><code>reg &lt;- (im &lt;&lt; 12)</code></td>
</tr>
<tr class="odd">
<td><code>AUIPC</code></td>
<td>add upper immediate to PC</td>
<td><code>reg &lt;- PC+(im &lt;&lt; 12)</code></td>
</tr>
<tr class="even">
<td><code>JAL</code></td>
<td>jump and link</td>
<td><code>reg &lt;- PC+4 ; PC &lt;- PC+imm</code></td>
</tr>
<tr class="odd">
<td><code>JALR</code></td>
<td>jump and link register</td>
<td><code>reg &lt;- PC+4 ; PC &lt;- reg+imm</code></td>
</tr>
<tr class="even">
<td><code>FENCE</code></td>
<td>memory-ordering for multicores</td>
<td>(not detailed here, skipped for now)</td>
</tr>
<tr class="odd">
<td><code>SYSTEM</code></td>
<td>system calls, breakpoints</td>
<td>(not detailed here, skipped for now)</td>
</tr>
</tbody>
</table>
<ul>
<li><p>The 6 branch variants are conditional jumps, that depend on a
test on two registers.</p></li>
<li><p>ALU operations can be of the form
<code>register &lt;- register OP register</code> or
<code>register &lt;- register OP immediate</code></p></li>
<li><p>Then we have load and store, that can operate on bytes, on 16 bit
values (called half-words) or 32 bit values (called words). In addition
byte and half-word loads can do sign expansion. The source/target
address is obtained by adding an immediate offset to the content of a
register.</p></li>
<li><p>The remaining instructions are more special (one may skip their
description in a first read, you just need to know that they are used to
implement unconditional jumps, function calls, memory ordering for
multicores, system calls and breaks):</p>
<ul>
<li><p><code>LUI</code> (load upper immediate) is used to load the upper
20 bits of a constant. The lower bits can then be set using
<code>ADDI</code> or <code>ORI</code>. At first sight it may seem weird
that we need two instructions to load a 32 bit constant in a register,
but in fact it is a smart choice, because all instructions are 32-bit
long.</p></li>
<li><p><code>AUIPC</code> (add upper immediate to PC) adds a constant to
the current program counter and places the result in a register. It is
meant to be used in combination with <code>JALR</code> to reach a 32-bit
PC-relative address.</p></li>
<li><p><code>JAL</code> (jump and link) adds an offset to the PC and
stores the address of the instruction following the jump in a register.
It can be used to implement function calls. <code>JALR</code> does the
same thing, but adds the offset to a register.</p></li>
<li><p><code>FENCE</code> and <code>SYSTEMS</code> are used to implement
memory ordering in multicore systems, and system calls/breaks
respectively.</p></li>
</ul></li>
</ul>
<p>To summarize, we got branches (conditional jumps), ALU operations,
load and store, and a couple of special instructions used to implement
unconditional jumps and function calls. There are also two functions for
memory ordering and system calls (but we will ignore these two ones for
now). OK, in fact only 9 instructions then, it seems doable… At this
point, I had not understood everything, so I’ll start from what I think
to be the simplest parts (intruction decoder, register file and ALU),
then we will see how things are interconnected, how to implement jumps,
branches, and all the instructions.</p>
<h2 id="step-4-the-instruction-decoder">Step 4: the instruction
decoder</h2>
<p>Now the idea is to have a memory with RISC-V instructions in it, load
all instructions sequentially (like in our christmas tinsel), in an
<code>instr</code> register, and see how to recognize among the 11
instructions (and light a different LED in function of the recognized
instruction). Each instruction is encoded in a 32-bits word, and we need
to decode the different bits of this word to recognize the instruction
and its parameters.</p>
<p>The <a
href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V
reference manual</a> has all the information that we need summarized in
two tables in page 130 (RV32/64G Instruction Set Listings).</p>
<p>Let us take a look at the big table, first thing to notice is that
the 7 LSBs tells you which instruction it is (there are 10
possibilities, we do not count <code>FENCE</code> for now).</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> instr<span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isALUreg  <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b0110011</span><span class="op">);</span> <span class="co">// rd &lt;- rs1 OP rs2   </span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isALUimm  <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b0010011</span><span class="op">);</span> <span class="co">// rd &lt;- rs1 OP Iimm</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isBranch  <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b1100011</span><span class="op">);</span> <span class="co">// if(rs1 OP rs2) PC&lt;-PC+Bimm</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isJALR    <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b1100111</span><span class="op">);</span> <span class="co">// rd &lt;- PC+4; PC&lt;-rs1+Iimm</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isJAL     <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b1101111</span><span class="op">);</span> <span class="co">// rd &lt;- PC+4; PC&lt;-PC+Jimm</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isAUIPC   <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b0010111</span><span class="op">);</span> <span class="co">// rd &lt;- PC + Uimm</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isLUI     <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b0110111</span><span class="op">);</span> <span class="co">// rd &lt;- Uimm   </span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isLoad    <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b0000011</span><span class="op">);</span> <span class="co">// rd &lt;- mem[rs1+Iimm]</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isStore   <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b0100011</span><span class="op">);</span> <span class="co">// mem[rs1+Simm] &lt;- rs2</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isSYSTEM  <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">7&#39;b1110011</span><span class="op">);</span> <span class="co">// special</span></span></code></pre></div>
<p>Besides the instruction type, we need also to decode the arguments of
the instruction. The table on the top distinguishes 6 types of
instructions
(<code>R-type</code>,<code>I-type</code>,<code>S-type</code>,<code>B-type</code>,<code>U-type</code>,<code>J-type</code>),
depending on the arguments of the instruction and how they are encoded
within the 32 bits of the instruction word.</p>
<p><code>R-type</code> instructions take two source registers
<code>rs1</code> and <code>rs2</code>, apply an operation on them and
stores the result in a third destination register <code>rd</code>
(<code>ADD</code>, <code>SUB</code>, <code>SLL</code>, <code>SLT</code>,
<code>SLTU</code>, <code>XOR</code>, <code>SRL</code>, <code>SRA</code>,
<code>OR</code>, <code>AND</code>).</p>
<p>Since RISC-V has 32 registers, each of
<code>rs1</code>,<code>rs2</code> and <code>rd</code> use 5 bits of the
instruction word. Interestingly, these are the same bits for all
instruction formats. Hence, “decoding” <code>rs1</code>,<code>rs2</code>
and <code>rd</code> is just a matter of drawing some wires from the
instruction word:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> rs1Id <span class="op">=</span> instr<span class="op">[</span><span class="dv">19</span><span class="op">:</span><span class="dv">15</span><span class="op">];</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> rs2Id <span class="op">=</span> instr<span class="op">[</span><span class="dv">24</span><span class="op">:</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> rdId  <span class="op">=</span> instr<span class="op">[</span><span class="dv">11</span><span class="op">:</span><span class="dv">7</span><span class="op">];</span></span></code></pre></div>
<p>Then, one needs to recognize among the 10 R-type instructions. It is
done mostly with the <code>funct3</code> field, a 3-bits code. With a
3-bits code, one can only encode 8 different instructions, hence there
is also a <code>funct7</code> field (7 MSBs of instruction word). Bit 30
of the instruction word encodes <code>ADD</code>/<code>SUB</code> and
<code>SRA</code>/<code>SRL</code> (arithmetic right shift with sign
expansion/logical right shift). The instruction decoder has wires for
<code>funct3</code> and <code>funct7</code>:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">2</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> funct3 <span class="op">=</span> instr<span class="op">[</span><span class="dv">14</span><span class="op">:</span><span class="dv">12</span><span class="op">];</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> funct7 <span class="op">=</span> instr<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">25</span><span class="op">];</span></span></code></pre></div>
<p><code>I-type</code> instructions take one register <code>rs1</code>,
an immediate value <code>Iimm</code>, applies an operation on them and
stores the result in the destination register <code>rd</code>
(<code>ADDI</code>, <code>SLTI</code>, <code>SLTIU</code>,
<code>XORI</code>, <code>ORI</code>, <code>ANDI</code>,
<code>SLLI</code>, <code>SRLI</code>, <code>SRAI</code>).</p>
<p><em>Wait a minute:</em> there are 10 R-Type instructions but only 9
I-Type instructions, why is this so ? If you look carefully, you will
see that there is no <code>SUBI</code>, but one can instead use
<code>ADDI</code> with a negative immediate value. This is a general
rule in RISC-V, if an existing functionality can be used, do not create
a new functionality.</p>
<p>As for R-type instructions, the instruction can be distinguished
using <code>funct3</code> and <code>funct7</code> (and in
<code>funct7</code>, only the bit 30 of the instruction word is used, to
distinguish <code>SRAI</code>/<code>SRLI</code> arithmetic and logical
right shifts).</p>
<p>The immediate value is encoded in the 12 MSBs of the instruction
word, hence we will draw additional wires to get it:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> Iimm<span class="op">={{</span><span class="dv">21</span><span class="op">{</span>instr<span class="op">[</span><span class="dv">31</span><span class="op">]}},</span> instr<span class="op">[</span><span class="dv">30</span><span class="op">:</span><span class="dv">20</span><span class="op">]};</span></span></code></pre></div>
<p>As can be seen, bit 31 of the instruction word is repeated 21 times,
this is “sign expansion” (converts a 12-bits signed quantity into a
32-bits one).</p>
<p>There are four other instruction formats <code>S-type</code> (for
Store), <code>B-type</code> (for Branch), <code>U-type</code> (for Upper
immediates that are left-shifted by 12), and <code>J-type</code> (for
Jumps). Each instruction format has a different way of encoding an
immediate value in the instruction word.</p>
<p>To understand what it means, let’s get back to Chapter 2, page 16.
The different instruction types correspond to the way <em>immediate
values</em> are encoded in them.</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 41%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>Instr. type</th>
<th>Description</th>
<th>Immediate value encoding</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>R-type</code></td>
<td>register-register ALU ops. <a
href="https://www.youtube.com/watch?v=pVWtI0426mU">more on this
here</a></td>
<td>None</td>
</tr>
<tr class="even">
<td><code>I-type</code></td>
<td>register-immediate integer ALU ops and <code>JALR</code>.</td>
<td>12 bits, sign expansion</td>
</tr>
<tr class="odd">
<td><code>S-type</code></td>
<td>store</td>
<td>12 bits, sign expansion</td>
</tr>
<tr class="even">
<td><code>B-type</code></td>
<td>branch</td>
<td>12 bits, sign expansion, upper <code>[31:1]</code> (bit 0 is 0)</td>
</tr>
<tr class="odd">
<td><code>U-type</code></td>
<td><code>LUI</code>,<code>AUIPC</code></td>
<td>20 bits, upper <code>31:12</code> (bits <code>[11:0]</code> are
0)</td>
</tr>
<tr class="even">
<td><code>J-type</code></td>
<td><code>JAL</code></td>
<td>12 bits, sign expansion, upper <code>[31:1]</code> (bit 0 is 0)</td>
</tr>
</tbody>
</table>
<p>Note that <code>I-type</code> and <code>S-type</code> encode the same
type of values (but they are taken from different parts of
<code>instr</code>). Same thing for <code>B-type</code> and
<code>J-type</code>.</p>
<p>One can decode the different types of immediates as follows:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> Uimm<span class="op">={</span>    instr<span class="op">[</span><span class="dv">31</span><span class="op">],</span>   instr<span class="op">[</span><span class="dv">30</span><span class="op">:</span><span class="dv">12</span><span class="op">],</span> <span class="op">{</span><span class="dv">12</span><span class="op">{</span><span class="bn">1&#39;b0</span><span class="op">}}};</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> Iimm<span class="op">={{</span><span class="dv">21</span><span class="op">{</span>instr<span class="op">[</span><span class="dv">31</span><span class="op">]}},</span> instr<span class="op">[</span><span class="dv">30</span><span class="op">:</span><span class="dv">20</span><span class="op">]};</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> Simm<span class="op">={{</span><span class="dv">21</span><span class="op">{</span>instr<span class="op">[</span><span class="dv">31</span><span class="op">]}},</span> instr<span class="op">[</span><span class="dv">30</span><span class="op">:</span><span class="dv">25</span><span class="op">],</span>instr<span class="op">[</span><span class="dv">11</span><span class="op">:</span><span class="dv">7</span><span class="op">]};</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> Bimm<span class="op">={{</span><span class="dv">20</span><span class="op">{</span>instr<span class="op">[</span><span class="dv">31</span><span class="op">]}},</span> instr<span class="op">[</span><span class="dv">7</span><span class="op">],</span>instr<span class="op">[</span><span class="dv">30</span><span class="op">:</span><span class="dv">25</span><span class="op">],</span>instr<span class="op">[</span><span class="dv">11</span><span class="op">:</span><span class="dv">8</span><span class="op">],</span><span class="bn">1&#39;b0</span><span class="op">};</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> Jimm<span class="op">={{</span><span class="dv">12</span><span class="op">{</span>instr<span class="op">[</span><span class="dv">31</span><span class="op">]}},</span> instr<span class="op">[</span><span class="dv">19</span><span class="op">:</span><span class="dv">12</span><span class="op">],</span>instr<span class="op">[</span><span class="dv">20</span><span class="op">],</span>instr<span class="op">[</span><span class="dv">30</span><span class="op">:</span><span class="dv">21</span><span class="op">],</span><span class="bn">1&#39;b0</span><span class="op">};</span></span></code></pre></div>
<p>Note that <code>Iimm</code>, <code>Simm</code>, <code>Bimm</code> and
<code>Jimm</code> do sign expansion (by copying bit 31 the required
number of times to fill the MSBs).</p>
<p>And that’s all for our instruction decoder ! To summarize, the
instruction decoder gets the following information from the instruction
word: - signals isXXX that recognizes among the 11 possible RISC-V
instructions - source and destination registers
<code>rs1</code>,<code>rs2</code> and <code>rd</code> - function codes
<code>funct3</code> and <code>funct7</code> - the five formats for
immediate values (with sign expansion for <code>Iimm</code>,
<code>Simm</code>, <code>Bimm</code> and <code>Jimm</code>).</p>
<p>Let us now initialize the memory with a few RISC-V instruction and
see whether we can recognize them by lighting a different LED depending
on the instruction (<a href="step4.v">step4.v</a>). To do that, we use
the big table in page 130 of the <a
href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V
reference manual</a>. It is a bit painful (we will see easier ways later
!). Using the <code>_</code> character to separate fields of a binary
constant is especially interesting under this circumstance.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>      <span class="co">// add x1, x0, x0</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">//                    rs2   rs1  add  rd  ALUREG</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>      MEM<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="bn">32&#39;b0000000_00000_00000_000_00001_0110011</span><span class="op">;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>      <span class="co">// addi x1, x1, 1</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">//             imm         rs1  add  rd   ALUIMM</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>      MEM<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="bn">32&#39;b000000000001_00001_000_00001_0010011</span><span class="op">;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>      <span class="co">// lw x2,0(x1)</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>      <span class="co">//             imm         rs1   w   rd   LOAD</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>      MEM<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="bn">32&#39;b000000000000_00001_010_00010_0000011</span><span class="op">;</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>      <span class="co">// sw x2,0(x1)</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">//             imm   rs2   rs1   w   imm  STORE</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>      MEM<span class="op">[</span><span class="dv">6</span><span class="op">]</span> <span class="op">=</span> <span class="bn">32&#39;b000000_00001_00010_010_00000_0100011</span><span class="op">;</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>      <span class="co">// ebreak</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>      <span class="co">//                                        SYSTEM</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>      MEM<span class="op">[</span><span class="dv">7</span><span class="op">]</span> <span class="op">=</span> <span class="bn">32&#39;b000000000001_00000_000_00000_1110011</span><span class="op">;</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span>     </span></code></pre></div>
<p>Then we can fetch and recognize the instructions as follows:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(!</span>resetn<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>     PC <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span> <span class="kw">else</span> <span class="kw">if</span><span class="op">(!</span>isSYSTEM<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>     instr <span class="op">&lt;=</span> MEM<span class="op">[</span>PC<span class="op">];</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>     PC <span class="op">&lt;=</span> PC<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> LEDS <span class="op">=</span> isSYSTEM <span class="op">?</span> <span class="dv">31</span> <span class="op">:</span> <span class="op">{</span>PC<span class="op">[</span><span class="dv">0</span><span class="op">],</span>isALUreg<span class="op">,</span>isALUimm<span class="op">,</span>isStore<span class="op">,</span>isLoad<span class="op">};</span></span></code></pre></div>
<p>(first led is wired to <code>PC[0]</code> so that we will see it
blinking even if there is the same instruction several times).</p>
<p>As you can see, the program counter is only incremented if
instruction is not <code>SYSTEM</code>. For now, the only
<code>SYSTEM</code> instruction that we support is <code>EBREAK</code>,
that halts execution.</p>
<p>In simulation mode, we can in addition display the name of the
recognized instruction and the fields:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`ifdef BENCH   </span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;PC=%0d&quot;</span><span class="op">,</span>PC<span class="op">);</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> <span class="op">(</span><span class="bn">1&#39;b1</span><span class="op">)</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isALUreg:</span> <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;ALUreg rd=%d rs1=%d rs2=%d funct3=%b&quot;</span><span class="op">,</span>rdId<span class="op">,</span> rs1Id<span class="op">,</span> rs2Id<span class="op">,</span> funct3<span class="op">);</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isALUimm:</span> <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;ALUimm rd=%d rs1=%d imm=%0d funct3=%b&quot;</span><span class="op">,</span>rdId<span class="op">,</span> rs1Id<span class="op">,</span> Iimm<span class="op">,</span> funct3<span class="op">);</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isBranch:</span> <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;BRANCH&quot;</span><span class="op">);</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isJAL:</span>    <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;JAL&quot;</span><span class="op">);</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isJALR:</span>   <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;JALR&quot;</span><span class="op">);</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isAUIPC:</span>  <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;AUIPC&quot;</span><span class="op">);</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isLUI:</span>    <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;LUI&quot;</span><span class="op">);</span>  </span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isLoad:</span>   <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;LOAD&quot;</span><span class="op">);</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isStore:</span>  <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;STORE&quot;</span><span class="op">);</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="dv">isSYSTEM:</span> <span class="dt">$display</span><span class="op">(</span><span class="st">&quot;SYSTEM&quot;</span><span class="op">);</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">endcase</span> </span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="ot">`endif</span></span></code></pre></div>
<p><strong>Try this</strong> run <code>step4.v</code> in simulation and
on the device. Try initializing the memory with different RISC-V
instruction and test whether the decoder recognizes them.</p>
<h2 id="sidebar-the-elegance-of-risc-v">Sidebar: the elegance of
RISC-V</h2>
<p>This paragraph may be skipped. it just contains my own impressions
and reflexions on the RISC-V instruction set, inspired by the comments
and Q&amp;A in italics in the <a
href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V
reference manual</a>.</p>
<p>At this point, I realized what an <em>instruction set
architecture</em> means: it is for sure a specification of <em>what bit
pattern does what</em> (Instruction Set) and it is also at the same time
driven by how this will be translated into wires (Architecture). An ISA
is not <em>abstract</em>, it is <em>independent</em> on an
implementation, but it is strongly designed with implementation in mind
! While the pipeline, branch prediction unit, multiple execution units,
caches may differ in different implementations, the instruction decoder
is probably very similar in all implementations.</p>
<p>There were things that seemed really weird to me in the first place:
all these immediate format variants, the fact that immediate values are
scrambled in different bits of <code>instr</code>, the <code>zero</code>
register, and the weird instructions
<code>LUI</code>,<code>AUIPC</code>,<code>JAL</code>,<code>JALR</code>.
When writing the instruction decoder, you better understand the reasons.
The ISA is really smart, and is the result of a long evolution (there
were RISC-I, RISC-II, … before). It seems to me the result of a
<em>distillation</em>. Now, in 2020, many things were tested in terms of
ISA, and this one seems to have benefited from all the previous
attempts, taking the good choices and avoiding the suboptimal ones.</p>
<p>What is really nice in the ISA is: - instruction size is fixed. Makes
things really easier. <em>(there are extension with varying instrution
length, but at least the core instruction set is simple)</em>; -
<code>rs1</code>,<code>rs2</code>,<code>rd</code> are always encoded by
the same bits of <code>instr</code>; - the immediate formats that need
to do sign expansion do it from the same bit (<code>instr[31]</code>); -
the weird instructions
<code>LUI</code>,<code>AUIPC</code>,<code>JAL</code>,<code>JALR</code>
can be combined to implement higher-level tasks (load 32-bit constant in
register, jump to arbitrary address, function calls). Their existence is
justified by the fact it makes the design easier. Then assembly
programmer’s life is made easier by <em>pseudo-instructions</em>
<code>CALL</code>, <code>RET</code>, … See <a
href="https://github.com/riscv/riscv-asm-manual/blob/master/riscv-asm.md">risc-v
assembly manual</a>, the two tables at the end of the page. Same thing
for tests/branch instructions obtained by swapping parameters
(e.g. <code>a &lt; b &lt;=&gt; b &gt; a</code> etc…), there are
pseudo-instructions that do the job for you.</p>
<p>Put differently, to appreciate the elegance of the RISC-V ISA,
imagine that your mission is to <em>invent it</em>. That is, invent both
the set of instructions and the way they are encoded as bit patterns.
The constraints are: - fixed instruction length (32 bits) - as simple as
possible: the ultimate sophistication is simplicity [Leonardo da Vinci]
!! - source and destination registers always encoded at the same
position - whenever there is sign-extension, it should be done from the
same bit - it should be simple to load an arbitrary 32-bits immediate
value in a register (but may take several instructions) - it should be
simple to jump to arbitrary memory locations (but may take several
instructions) - it should be simple to implement function calls (but may
take several instructions)</p>
<p>Then you understand why there are many different immediate formats.
For instance, consider <code>JAL</code>, that does not have a source
register, as compared to <code>JALR</code> that has one. Both take an
immediate value, but <code>JAL</code> has 5 more bits available to store
it, since it does not need to encode the source register. The slightest
available bit is used to extend the dynamic range of the immediates.
This explains both the multiple immediate formats and the fact that they
are assembled from multiple pieces of <code>instr</code>, slaloming
between the three fixed 5-bits register encodings, that are there or not
depending on the cases.</p>
<p>Now the rationale behind the weird instructions
<code>LUI</code>,<code>AUIPC</code>,<code>JAL</code> and
<code>JALR</code> is to give a set of functions that can be combined to
load arbitrary 32-bit values in register, or to jump to arbitrary
locations in memory, or to implement the function call protocol as
simply as possible. Considering the constraints, the taken choices (that
seemed weird to me in the first place) perfectly make sense. In
addition, with the taken choices, the instruction decoder is pretty
simple and has a low logical depth. Besides the 7-bits instruction
decoder, it mostly consists of a set of wires drawn from the bits of
<code>instr</code>, and duplication of the sign-extended bit 31 to form
the immediate values.</p>
<p>Before moving forward, I’d like to say a word about the
<code>zero</code> register. I think it is really a smart move. With it,
you do not need a <code>MOV rd rs</code> instruction (just
<code>ADD rd rs zero</code>), you do not need a <code>NOP</code>
instruction (<code>ADD zero zero zero</code>), and all the branch
variants can compare with <code>zero</code> ! I think that
<code>zero</code> is a great invention, not as great as <code>0</code>,
but really makes the instruction set more compact.</p>
<h2 id="step-5-the-register-bank-and-the-state-machine">Step 5: The
register bank and the state machine</h2>
<p>The register bank is implemented as follows:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> RegisterBank <span class="op">[</span><span class="dv">0</span><span class="op">:</span><span class="dv">31</span><span class="op">];</span></span></code></pre></div>
<p>Let us take a closer look at what we need to to to execute an
instruction. Condider for instance a stream of R-type instructions. For
each instruction, we need to do the following four things:</p>
<ul>
<li>fetch the instruction: <code>instr &lt;= MEM[PC]</code></li>
<li>fetch the values of <code>rs1</code> and <code>rs2</code>:
<code>rs1 &lt;= RegisterBank[rs1Id]; rs2 &lt;= RegisterBank[rs2Id]</code>
where <code>rs1</code> and <code>rs2</code> are two registers. We need
to do that because <code>RegisterBank</code> will be synthesized as a
block of BRAM, and one needs one cycle to access the content of
BRAM.</li>
<li>compute <code>rs1</code> <code>OP</code> <code>rs2</code> (where
<code>OP</code> depends on <code>funct3</code> and
<code>funct7</code>)</li>
<li>store the result in <code>rd</code>:
<code>RegisterBank[rdId] &lt;= writeBackData</code>. This can be done
during the same cycle as the previous step if <code>OP</code> is
computed by a combinatorial circuit.</li>
</ul>
<p>The first three operations are implemented by a state machine, as
follows (see <a href="step5.v">step5.v</a>):</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> FETCH_INSTR <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> FETCH_REGS  <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> EXECUTE     <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">1</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> state <span class="op">=</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">case</span><span class="op">(</span>state<span class="op">)</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>       <span class="dv">FETCH_INSTR:</span> <span class="kw">begin</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>          instr <span class="op">&lt;=</span> MEM<span class="op">[</span>PC<span class="op">];</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> FETCH_REGS<span class="op">;</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>       <span class="dv">FETCH_REGS:</span> <span class="kw">begin</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>          rs1 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>rs1Id<span class="op">];</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>          rs2 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>rs2Id<span class="op">];</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> EXECUTE<span class="op">;</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>       <span class="dv">EXECUTE:</span> <span class="kw">begin</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>          PC <span class="op">&lt;=</span> PC <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> FETCH_INSTR<span class="op">;</span>       </span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>     <span class="kw">endcase</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span> </span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span> </span></code></pre></div>
<p>The fourth one (register write-back) is implemented in this
block:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> writeBackData <span class="op">=</span> ... <span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> writeBackEn <span class="op">=</span> ...<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@</span>posedge<span class="op">(</span>clk<span class="op">)</span> <span class="kw">begin</span>   </span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>writeBackEn <span class="op">&amp;&amp;</span> rdId <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>          RegisterBank<span class="op">[</span>rdId<span class="op">]</span> <span class="op">&lt;=</span> writeBackData<span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>Remember that writing to register 0 has no effect (hence the test
<code>rdId != 0</code>). The signal <code>writeBackEn</code> is asserted
whenever <code>writeBackData</code> should be written to register
<code>rdId</code>. The data to be written back
(<code>writeBackData</code>) will be obtained from the ALU, as explained
in the next episode.</p>
<p><strong>Try this</strong>: run <a href="step5.v">step5.v</a> in
simulation and on the device. You will see your wannabe CPU’s state
machine dancing waltz on the LEDs (that display the current state).</p>
<h2 id="step-6-the-alu">Step 6: the ALU</h2>
<p>Now we can fetch instructions from memory, decode them and read
register values, but our (wannabe) CPU is still unable to do anything.
Let us see how to do actual computations on register’s values.</p>
<p><em>So, are you going to create an <code>ALU</code> module ? And by
the way, why did not you create a <code>Decoder</code> module, and a
<code>RegisterBank</code> module ?</em></p>
<p>My very first design used multiple modules and multiple files, for a
total of 1000 lines of code or so, then Matthias Koch wrote a monolithic
version, that fits in 200 lines of code. Not only it is more compact,
but also it is much easier to understand when you got everything in one
place. <strong>Rule of thumb:</strong> if you have more boxes and wires
between the boxes than circuitry in the boxes, then you have too many
boxes !</p>
<p><em>But wait a minute, modular design is good, no ?</em></p>
<p>Modular design is neither good nor bad, it is useful whenever it
makes things simpler. It is not the case in the present situation. There
is no absolute answer though, it is a matter of taste and style ! In
this tutorial, we use a (mostly) monolithic design.</p>
<p>Now we want to implement two types of instructions: - Rtype:
<code>rd</code> &lt;- <code>rs1</code> <code>OP</code> <code>rs2</code>
(recognized by <code>isALUreg</code>) - Itype: <code>rd</code> &lt;-
<code>rs1</code> <code>OP</code> <code>Iimm</code> (recognized by
<code>isALUimm</code>)</p>
<p>The ALU takes two inputs <code>aluIn1</code> and <code>aluIn2</code>,
computes <code>aluIn1</code> <code>OP</code> <code>aluIn2</code> and
stores it in <code>aluOut</code>:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> aluIn1 <span class="op">=</span> rs1<span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> aluIn2 <span class="op">=</span> isALUreg <span class="op">?</span> rs2 <span class="op">:</span> Iimm<span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> aluOut<span class="op">;</span></span></code></pre></div>
<p>Depending on the instruction type, <code>aluIn2</code> is either the
value in the second source register <code>rs2</code>, or an immediate in
the <code>Itype</code> format (<code>Immm</code>). The operation
<code>OP</code> depends mostly on <code>funct3</code> (and also on
<code>funct7</code>). Keep a copy of the <a
href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V
reference manual</a> open page 130 on your knees or in another
window:</p>
<table>
<thead>
<tr class="header">
<th>funct3</th>
<th>operation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3’b000</td>
<td><code>ADD</code> or <code>SUB</code></td>
</tr>
<tr class="even">
<td>3’b001</td>
<td>left shift</td>
</tr>
<tr class="odd">
<td>3’b010</td>
<td>signed comparison (&lt;)</td>
</tr>
<tr class="even">
<td>3’b011</td>
<td>unsigned comparison (&lt;)</td>
</tr>
<tr class="odd">
<td>3’b100</td>
<td><code>XOR</code></td>
</tr>
<tr class="even">
<td>3’b101</td>
<td>logical right shift or arithmetic right shift</td>
</tr>
<tr class="odd">
<td>3’b110</td>
<td><code>OR</code></td>
</tr>
<tr class="even">
<td>3’b111</td>
<td><code>AND</code></td>
</tr>
</tbody>
</table>
<ul>
<li>for <code>ADD</code>/<code>SUB</code>, if its an <code>ALUreg</code>
operation (Rtype), then one makes the difference between
<code>ADD</code> and <code>SUB</code> by testing bit 5 of
<code>funct7</code> (1 for <code>SUB</code>). If it is an
<code>ALUimm</code> operation (Itype), then it can be only
<code>ADD</code>. In this context, one just needs to test bit 5 of
<code>instr</code> to distinguish between <code>ALUreg</code> (if it is
1) and <code>ALUimm</code> (if it is 0).</li>
<li>for logical or arithmetic right shift, one makes the difference also
by testing bit 5 of <code>funct7</code>, 1 for arithmetic shift (with
sign expansion) and 0 for logical shift.</li>
<li>the shift amount is either the content of <code>rs2</code> for
<code>ALUreg</code> instructions or <code>instr[24:20]</code> (the same
bits as <code>rs2Id</code>) for <code>ALUimm</code> instructions.</li>
</ul>
<p>Putting everything together, one gets the following VERILOG code for
the ALU:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> aluOut<span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> shamt <span class="op">=</span> isALUreg <span class="op">?</span> rs2<span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span> instr<span class="op">[</span><span class="dv">24</span><span class="op">:</span><span class="dv">20</span><span class="op">];</span> <span class="co">// shift amount</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span>*<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span><span class="op">(</span>funct3<span class="op">)</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b000</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>funct7<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">&amp;</span> instr<span class="op">[</span><span class="dv">5</span><span class="op">])</span> <span class="op">?</span> <span class="op">(</span>aluIn1<span class="op">-</span>aluIn2<span class="op">)</span> <span class="op">:</span> <span class="op">(</span>aluIn1<span class="op">+</span>aluIn2<span class="op">);</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b001</span><span class="op">:</span> aluOut <span class="op">=</span> aluIn1 <span class="op">&lt;&lt;</span> shamt<span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b010</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span><span class="dt">$signed</span><span class="op">(</span>aluIn1<span class="op">)</span> <span class="op">&lt;</span> <span class="dt">$signed</span><span class="op">(</span>aluIn2<span class="op">));</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b011</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">&lt;</span> aluIn2<span class="op">);</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b100</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">^</span> aluIn2<span class="op">);</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b101</span><span class="op">:</span> aluOut <span class="op">=</span> funct7<span class="op">[</span><span class="dv">5</span><span class="op">]?</span> <span class="op">(</span><span class="dt">$signed</span><span class="op">(</span>aluIn1<span class="op">)</span> <span class="op">&gt;&gt;&gt;</span> shamt<span class="op">)</span> <span class="op">:</span> <span class="op">(</span>aluIn1 <span class="op">&gt;&gt;</span> shamt<span class="op">);</span> </span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b110</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">|</span> aluIn2<span class="op">);</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b111</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">&amp;</span> aluIn2<span class="op">);</span> </span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">endcase</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p><em>Note:</em> although it is declared as a <code>reg</code>,
<code>aluOut</code> will be a combinatorial function (no flipflop
generated), because its value is determined in a combinatorial block
(<code>always @(*)</code>), and all the configurations are enumerated in
the <code>case</code> statement.</p>
<p>Register write-back is configured as follows:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> writeBackData <span class="op">=</span> aluOut<span class="op">;</span> </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> writeBackEn <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> EXECUTE <span class="op">&amp;&amp;</span> <span class="op">(</span>isALUreg <span class="op">||</span> isALUimm<span class="op">));</span>   </span></code></pre></div>
<p><strong>Try this</strong> run <a href="step6.v">step6.v</a> in
simulation and on the device. In simulation it will display the written
value and the written register for all register write-back operation. On
the device it will show the 5 LSBs of <code>x1</code> on the LEDs. Then
you can try changing the program, and observe the effect on register
values.</p>
<p><strong>You are here !</strong> This is the list of instructions you
have to implement, your wannabe RISC-V core currently supports 20 of
them. Next steps: jumps, then branches, then… the rest. Before then, as
you probably have noticed, translating RISC-V programs into binary (that
is, assembling manually) is extremely painful. Next section gives a much
easier solution.</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>ALUreg</th>
<th>ALUimm</th>
<th>Jump</th>
<th>Branch</th>
<th>LUI</th>
<th>AUIPC</th>
<th>Load</th>
<th>Store</th>
<th>SYSTEM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[*] 10</td>
<td>[*] 9</td>
<td>[ ] 2</td>
<td>[ ] 6</td>
<td>[ ]</td>
<td>[ ]</td>
<td>[ ] 5</td>
<td>[ ] 3</td>
<td>[*] 1</td>
</tr>
</tbody>
</table>
<h2 id="step-7-using-the-verilog-assembler">Step 7: using the VERILOG
assembler</h2>
<p>To avoid having to manually translate RISC-V assembly into binary,
one can use the GNU assembler, generate a binary file, translate it into
hexadecimal and use the VERILOG function <code>readmemh()</code> to
initialize memory with the content of that file. We will see later how
to do that.</p>
<p>But in our case, it would be very convenient to be able to write
small assembly programs directly in the same VERILOG file as our design.
In fact, it is possible to do so, by implementing a RISC-V assembler
directly in VERILOG (using tasks and functions), as done in <a
href="riscv_assembly.v">riscv_assembly.v</a>.</p>
<p>In <a href="step7.v">step7.v</a>, memory is initialized with the same
assembly program as in <a href="step6.v">step6.v</a>. It looks like that
now, Much easier to read, no ?</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`include</span> <span class="st">&quot;riscv_assembly.v&quot;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>x0<span class="op">,</span>x0<span class="op">,</span>x0<span class="op">);</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>x1<span class="op">,</span>x0<span class="op">,</span>x0<span class="op">);</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>x1<span class="op">,</span>x1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>x1<span class="op">,</span>x1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>x1<span class="op">,</span>x1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>x1<span class="op">,</span>x1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>x2<span class="op">,</span>x1<span class="op">,</span>x0<span class="op">);</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>x3<span class="op">,</span>x1<span class="op">,</span>x2<span class="op">);</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>      SRLI<span class="op">(</span>x3<span class="op">,</span>x3<span class="op">,</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>      SLLI<span class="op">(</span>x3<span class="op">,</span>x3<span class="op">,</span><span class="dv">31</span><span class="op">);</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>      SRAI<span class="op">(</span>x3<span class="op">,</span>x3<span class="op">,</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>      SRLI<span class="op">(</span>x1<span class="op">,</span>x3<span class="op">,</span><span class="dv">26</span><span class="op">);</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>      EBREAK<span class="op">();</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p><em>Note:</em> <code>riscv_assembly.v</code> needs to be included
from inside the module that uses assembly.</p>
<p>In this step, we make another modification: in the previous steps,
<code>PC</code> was the index of the current instruction. For what
follows, we want it to be the <em>address</em> of the current
instruction. Since each instruction is 32-bits long, it means that: - to
increment <code>PC</code>, we do <code>PC &lt;= PC + 4</code> (instead
of <code>PC &lt;= PC + 1</code> as before) - to fetch the current
instruction, we do <code>instr &lt;= MEM[PC[31:2]];</code> (we ignore
the two LSBs of <code>PC</code>).</p>
<h2 id="step-8-jumps">Step 8: jumps</h2>
<p>There are two jump instructions, <code>JAL</code> (jump and link),
and <code>JALR</code> (jump and link register). By “and link”, one means
that the current PC can be written to a register. Hence <code>JAL</code>
and <code>JALR</code> can be used to implement not only jumps, but also
function calls. Here is what the two instructions are supposed to
do:</p>
<table>
<thead>
<tr class="header">
<th>instruction</th>
<th>effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>JAL rd,imm</td>
<td>rd&lt;-PC+4; PC&lt;-PC+Jimm</td>
</tr>
<tr class="even">
<td>JALR rd,rs1,imm</td>
<td>rd&lt;-PC+4; PC&lt;-rs1+Iimm</td>
</tr>
</tbody>
</table>
<p>To implement these two instructions, we need to make the following
changes to our core. First thing is register write-back: now value can
be <code>PC+4</code> instead of <code>aluOut</code> for jump
instructions:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> writeBackData <span class="op">=</span> <span class="op">(</span>isJAL <span class="op">||</span> isJALR<span class="op">)</span> <span class="op">?</span> <span class="op">(</span>PC <span class="op">+</span> <span class="dv">4</span><span class="op">)</span> <span class="op">:</span> aluOut<span class="op">;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> writeBackEn <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> EXECUTE <span class="op">&amp;&amp;</span> </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>             <span class="op">(</span>isALUreg <span class="op">||</span> </span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>              isALUimm <span class="op">||</span> </span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>              isJAL    <span class="op">||</span> </span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>              isJALR<span class="op">)</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>             <span class="op">);</span></span></code></pre></div>
<p>We also need to declare a <code>nextPC</code> value, that implements
the three possibilities:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> nextPC <span class="op">=</span> isJAL  <span class="op">?</span> PC<span class="op">+</span>Jimm <span class="op">:</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>                    isJALR <span class="op">?</span> rs1<span class="op">+</span>Iimm <span class="op">:</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                    PC<span class="op">+</span><span class="dv">4</span><span class="op">;</span></span></code></pre></div>
<p>Then, in the state machine, the line <code>PC &lt;= PC + 4;</code> is
replaced with <code>PC &lt;= nextPC;</code> and that’s all !</p>
<p>We can now implement a simple (infinite) loop to test our new jump
instruction:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`include </span><span class="fl">&quot;riscv_assembly.v&quot;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>      <span class="dt">integer</span> L0_<span class="op">=</span><span class="dv">4</span><span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>     ADD<span class="op">(</span>x1<span class="op">,</span>x0<span class="op">,</span>x0<span class="op">);</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>      Label<span class="op">(</span>L0_<span class="op">);</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>     ADDI<span class="op">(</span>x1<span class="op">,</span>x1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>     JAL<span class="op">(</span>x0<span class="op">,</span>LabelRef<span class="op">(</span>L0_<span class="op">));</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>     EBREAK<span class="op">();</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>     endASM<span class="op">();</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span></code></pre></div>
<p>The integer <code>L0_</code> is a label. Unlike with a real
assembler, we need to specify the value of <code>L0_</code> by hand.
Here it is easy, <code>L0_</code> is right after the first instruction,
hence it corresponds to the beginning of the RAM (0) plus one 32-bits
words, that is, 4. For longer programs with many labels, you can let the
labels uninitialized (<code>integer L0_;</code>) then the first time you
run the program, it will compute and display the values to be used for
the labels. It is not super-convenient, but still much better than
assembling by hand / determining the labels by hand.</p>
<p>The <code>LabelRef()</code> function computes the label’s offset
relative to the current program counter. In addition, in simulation
mode, it displays the current address (to be used to initialize the
label), and if the label was already initialized (like here with
<code>L0_=4</code>) it checks that the label corresponds to the current
address generated by the assembler. If it is not the case, the
<code>endASM()</code> statement displays an error message and exits.</p>
<p><em>Note 1</em>: I systematically insert an <code>EBREAK()</code>
instruction at the end of the program, here it would not be necessary
(we have an infinite loop), but if I change my mind and exit the loop,
then <code>EBREAK()</code> is already there.</p>
<p><em>Note 2</em>: the <code>endASM();</code> statement checks the
validity of all the labels and exits simulation whenever an invalid
label is detected. If you use the RISC-V VERILOG assembler,
systematically run your design in simulation before synthesizing
(because this verification cannot be done at synthesis time).</p>
<p><strong>Try this</strong> Run the design <a
href="step8.v">step8.v</a> in simulation and on the device. Yes, after 8
steps, what we have is just another stupid blinky ! But this time, this
blinky is executing a real RISC-V program ! It is not a complete RISC-V
core yet, but it starts to have a strong RISC-V flavor. Be patient, our
core will be soon able to run RISC-V programs that are more interesting
than a blinky.</p>
<p><strong>You are here !</strong> Still some work to do, but we are
making progress. | ALUreg | ALUimm | Jump | Branch | LUI | AUIPC | Load
| Store | SYSTEM | |——–|——–|——-|——–|—–|——-|——-|——-|——–| | [*] 10 | [*] 9
| [*] 2 | [ ] 6 | [ ] | [ ] | [ ] 5 | [ ] 3 | [*] 1 |</p>
<p><strong>Try this</strong> add a couple of instructions before the
loop, run in simulation, fix the label as indicated by the simulator,
re-run in simulation, run on device.</p>
<h2 id="step-9-branches">Step 9: Branches</h2>
<p>Branches are like jumps, except that they compare two register, and
update <code>PC</code> based on the result of the comparison. Another
difference is that they are more limited in the address range they can
reach from <code>PC</code> (12-bits offset). There are 6 different
branch instructions:</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>instruction</th>
<th>effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BEQ rs1,rs2,imm</td>
<td>if(rs1 == rs2) PC &lt;- PC+Bimm</td>
</tr>
<tr class="even">
<td>BNE rs1,rs2,imm</td>
<td>if(rs1 != rs2) PC &lt;- PC+Bimm</td>
</tr>
<tr class="odd">
<td>BLT rs1,rs2,imm</td>
<td>if(rs1 &lt; rs2) PC &lt;- PC+Bimm (signed comparison)</td>
</tr>
<tr class="even">
<td>BGE rs1,rs2,imm</td>
<td>if(rs1 &gt;= rs2) PC &lt;- PC+Bimm (signed comparison)</td>
</tr>
<tr class="odd">
<td>BLTU rs1,rs2,imm</td>
<td>if(rs1 &lt; rs2) PC &lt;- PC+Bimm (unsigned comparison)</td>
</tr>
<tr class="even">
<td>BGEU rs1,rs2,imm</td>
<td>if(rs1 &gt;= rs2) PC &lt;- PC+Bimm (unsigned comparison)</td>
</tr>
</tbody>
</table>
<p><em>Wait a minute:</em> there is <code>BLT</code>, but where is
<code>BGT</code> ? Always the same principle in a RISC-V processor: if
something can be done with a functionality that is already there, do not
add a new functionality ! In this case, <code>BGT rs1,rs2,imm</code> is
equivalent to <code>BLT rs2,rs1,imm</code> (just swap the first two
operands). If you use <code>BGT</code> in a RISC-V assembly program, it
will work (and the assembler replaces it with <code>BLT</code> with
swapped operands). <code>BGT</code> is called a “pseudo-instruction”.
There are many pseudo-instructions to make RISC-V assembly programmer’s
life easier (more on this later).</p>
<p>Back to our branch instructions, we will need to add in the ALU some
wires to compute the result of the test, as follows:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> takeBranch<span class="op">;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span>*<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span><span class="op">(</span>funct3<span class="op">)</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b000</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="op">(</span>rs1 <span class="op">==</span> rs2<span class="op">);</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b001</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="op">(</span>rs1 <span class="op">!=</span> rs2<span class="op">);</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b100</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="op">(</span><span class="dt">$signed</span><span class="op">(</span>rs1<span class="op">)</span> <span class="op">&lt;</span> <span class="dt">$signed</span><span class="op">(</span>rs2<span class="op">));</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b101</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="op">(</span><span class="dt">$signed</span><span class="op">(</span>rs1<span class="op">)</span> <span class="op">&gt;=</span> <span class="dt">$signed</span><span class="op">(</span>rs2<span class="op">));</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b110</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="op">(</span>rs1 <span class="op">&lt;</span> rs2<span class="op">);</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b111</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="op">(</span>rs1 <span class="op">&gt;=</span> rs2<span class="op">);</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">default</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="bn">1&#39;b0</span><span class="op">;</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">endcase</span></span></code></pre></div>
<p><em>Note 1</em> it is possible to create a much more compact ALU,
that uses a much smaller number of LUTs when synthesized, we sill see
that later (for now, our goal is to have a RISC-V processor that works,
we will optimize it later).</p>
<p><em>Note 2</em> Among the 8 possibilites given by
<code>funct3</code>, only 6 of them are used by the branch instructions.
It is necessary to have a <code>default:</code> statement in the
<code>case</code>, else the synthesizer would not be able to keep
<code>takeBranch</code> as purely combinatorial (and would generate a
latch, which we do not want).</p>
<p>Now the only thing that remains to do for implementing branches is to
add a case for <code>nextPC</code>, as follows:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> nextPC <span class="op">=</span> <span class="op">(</span>isBranch <span class="op">&amp;&amp;</span> takeBranch<span class="op">)</span> <span class="op">?</span> PC<span class="op">+</span>Bimm <span class="op">:</span>           </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>                    isJAL                    <span class="op">?</span> PC<span class="op">+</span>Jimm <span class="op">:</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                    isJALR                   <span class="op">?</span> rs1<span class="op">+</span>Iimm <span class="op">:</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>                    PC<span class="op">+</span><span class="dv">4</span><span class="op">;</span></span></code></pre></div>
<p>We are now ready to test a simple loop, that counts from 0 to 31,
displays each iteration on the LEDs (remember, they are wired to
<code>x1</code>) and stops:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>include <span class="st">&quot;riscv_assembly.v&quot;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>      integer L0_ <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>      initial begin</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>         ADD<span class="op">(</span>x1<span class="op">,</span>x0<span class="op">,</span>x0<span class="op">);</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>         ADDI<span class="op">(</span>x2<span class="op">,</span>x0<span class="op">,</span><span class="dv">32</span><span class="op">);</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>      Label<span class="op">(</span>L0_<span class="op">);</span> </span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>     ADDI<span class="op">(</span>x1<span class="op">,</span>x1<span class="op">,</span><span class="dv">1</span><span class="op">);</span> </span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>         BNE<span class="op">(</span>x1<span class="op">,</span> x2<span class="op">,</span> LabelRef<span class="op">(</span>L0_<span class="op">));</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>         EBREAK<span class="op">();</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>     endASM<span class="op">();</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>      end</span></code></pre></div>
<p><strong>Try this</strong> run <a href="step9.v">step9.v</a> in
simulation and on device. Try modifying the program, create a “knight
driver” blinky with an outer loop and two inner loops (one left to right
and one right to left).</p>
<p><strong>You are here !</strong> Wow, we have implemented 28
instructions out of 38 ! Let us continue…</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>ALUreg</th>
<th>ALUimm</th>
<th>Jump</th>
<th>Branch</th>
<th>LUI</th>
<th>AUIPC</th>
<th>Load</th>
<th>Store</th>
<th>SYSTEM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[*] 10</td>
<td>[*] 9</td>
<td>[*] 2</td>
<td>[ *] 6</td>
<td>[ ]</td>
<td>[ ]</td>
<td>[ ] 5</td>
<td>[ ] 3</td>
<td>[*] 1</td>
</tr>
</tbody>
</table>
<h2 id="step-10-lui-and-auipc">Step 10: LUI and AUIPC</h2>
<p>We still have these two weird instructions to implement. What do they
do ? It is rather simple:</p>
<table>
<thead>
<tr class="header">
<th>instruction</th>
<th>effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LUI rd, imm</td>
<td>rd &lt;= Uimm</td>
</tr>
<tr class="even">
<td>AUIPC rd, imm</td>
<td>rd &lt;= PC + Uimm</td>
</tr>
</tbody>
</table>
<p>And if you look at the <code>Uimm</code> format, it reads its MSBs
(<code>imm[31:12]</code>) from the immediate encoded in the
instructions. The 12 LSBs are set to zero. These two instructions are
super useful: the immediate formats supported by all the other
instructions can only modify the LSBs. Combined with these two
functions, one can load an arbitrary value in a register (but this can
require up to two instructions).</p>
<p>Implementing these two instructions just requires to change
<code>writeBackEn</code> and <code>writeBackData</code> as follows:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> writeBackData <span class="op">=</span> <span class="op">(</span>isJAL <span class="op">||</span> isJALR<span class="op">)</span> <span class="op">?</span> <span class="op">(</span>PC <span class="op">+</span> <span class="dv">4</span><span class="op">)</span> <span class="op">:</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>              <span class="op">(</span>isLUI<span class="op">)</span> <span class="op">?</span> Uimm <span class="op">:</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>              <span class="op">(</span>isAUIPC<span class="op">)</span> <span class="op">?</span> <span class="op">(</span>PC <span class="op">+</span> Uimm<span class="op">)</span> <span class="op">:</span> </span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>              aluOut<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> writeBackEn <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> EXECUTE <span class="op">&amp;&amp;</span> </span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>             <span class="op">(</span>isALUreg <span class="op">||</span> </span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>              isALUimm <span class="op">||</span> </span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>              isJAL    <span class="op">||</span> </span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>              isJALR   <span class="op">||</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>              isLUI    <span class="op">||</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>              isAUIPC<span class="op">)</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>             <span class="op">);</span></span></code></pre></div>
<p><strong>You are here !</strong> Seems that we are nearly there ! 8
instructions to go…</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>ALUreg</th>
<th>ALUimm</th>
<th>Jump</th>
<th>Branch</th>
<th>LUI</th>
<th>AUIPC</th>
<th>Load</th>
<th>Store</th>
<th>SYSTEM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[*] 10</td>
<td>[*] 9</td>
<td>[*] 2</td>
<td>[ *] 6</td>
<td>[*]</td>
<td>[*]</td>
<td>[ ] 5</td>
<td>[ ] 3</td>
<td>[*] 1</td>
</tr>
</tbody>
</table>
<p><strong>Try this</strong> run <a href="step10.v">step10.v</a> in
simulation and on the device.</p>
<p><em>Argh !!</em> On my icestick, it does not fit (requires 1283 LUTs
and the IceStick only has 1280). What can we do ? Remember, we
absolutely took no care about resource consumption, just trying to write
a design that works. In fact, there is <em>a lot</em> of room for
improvement in our design, we will see that later, but before then,
let’s organize our SOC a bit better (then we will shrink the
processor).</p>
<h2 id="step-11-memory-in-a-separate-module">Step 11: Memory in a
separate module</h2>
<p>In our previous designs, we got everything in our <code>SOC</code>
module (memory and processor). In this step, we will see how to separate
them.</p>
<p>First, the <code>Memory</code> module:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Memory <span class="op">(</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>             clk<span class="op">,</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>      <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_addr<span class="op">,</span>  <span class="co">// address to be read</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">output</span> <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_rdata<span class="op">,</span> <span class="co">// data read from memory</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>         mem_rstrb  <span class="co">// goes high when processor wants to read</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> MEM <span class="op">[</span><span class="dv">0</span><span class="op">:</span><span class="dv">255</span><span class="op">];</span> </span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="ot">`include </span><span class="fl">&quot;riscv_assembly.v&quot;</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> L0_<span class="op">=</span><span class="dv">8</span><span class="op">;</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>                  ADD<span class="op">(</span>x1<span class="op">,</span>x0<span class="op">,</span>x0<span class="op">);</span>      </span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>                  ADDI<span class="op">(</span>x2<span class="op">,</span>x0<span class="op">,</span><span class="dv">31</span><span class="op">);</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>      Label<span class="op">(</span>L0_<span class="op">);</span> ADDI<span class="op">(</span>x1<span class="op">,</span>x1<span class="op">,</span><span class="dv">1</span><span class="op">);</span> </span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>                  BNE<span class="op">(</span>x1<span class="op">,</span> x2<span class="op">,</span> LabelRef<span class="op">(</span>L0_<span class="op">));</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>                  EBREAK<span class="op">();</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>      endASM<span class="op">();</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>mem_rstrb<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>         mem_rdata <span class="op">&lt;=</span> MEM<span class="op">[</span>mem_addr<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">2</span><span class="op">]];</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>In its interface, there is a <code>clk</code> signal connected to the
clock. Whenever the processor wants to read in memory, it positions the
address to be read on <code>mem_addr</code>, and sets
<code>mem_rstrb</code> to 1. Then the <code>Memory</code> module returns
the data to be read on <code>mem_rdata</code>.</p>
<p>Symetrically, the <code>Processor</code> module has a
<code>mem_addr</code> signal (as <code>output</code> this time), a
<code>mem_rdata</code> signal (as input) and a <code>mem_rstrb</code>
signal (as output):</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Processor <span class="op">(</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>         clk<span class="op">,</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>         resetn<span class="op">,</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span>     <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_addr<span class="op">,</span> </span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>      <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_rdata<span class="op">,</span> </span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span>        mem_rstrb<span class="op">,</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> x1          </span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>(in addition, we have a <code>x1</code> signal that contains the
contents of register <code>x1</code>, that can be used for visual
debugging. We will plug it to the LEDs).</p>
<p>The state machine has one additional state:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> FETCH_INSTR <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> WAIT_INSTR  <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> FETCH_REGS  <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> EXECUTE     <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">case</span><span class="op">(</span>state<span class="op">)</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>     <span class="dv">FETCH_INSTR:</span> <span class="kw">begin</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>       state <span class="op">&lt;=</span> WAIT_INSTR<span class="op">;</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>     <span class="kw">end</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>     <span class="dv">WAIT_INSTR:</span> <span class="kw">begin</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>       instr <span class="op">&lt;=</span> mem_rdata<span class="op">;</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>       state <span class="op">&lt;=</span> FETCH_REGS<span class="op">;</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>     <span class="kw">end</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>     <span class="dv">FETCH_REGS:</span> <span class="kw">begin</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>       rs1 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>rs1Id<span class="op">];</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>       rs2 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>rs2Id<span class="op">];</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>       state <span class="op">&lt;=</span> EXECUTE<span class="op">;</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>     <span class="kw">end</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>     <span class="dv">EXECUTE:</span> <span class="kw">begin</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(!</span>isSYSTEM<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>       PC <span class="op">&lt;=</span> nextPC<span class="op">;</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>    state <span class="op">&lt;=</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>   <span class="kw">endcase</span> </span></code></pre></div>
<p><em>Note</em> we will see later how to simplify it and get back to
three states.</p>
<p>Now, <code>mem_addr</code> and <code>mem_rstrb</code> can be wired as
follows:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_addr <span class="op">=</span> PC<span class="op">;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_rstrb <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> FETCH_INSTR<span class="op">);</span></span></code></pre></div>
<p>And finally, everything is installed and connected in the
<code>SOC</code></p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> SOC <span class="op">(</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>  CLK<span class="op">,</span>        <span class="co">// system clock </span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>  RESET<span class="op">,</span>      <span class="co">// reset button</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> LEDS<span class="op">,</span> <span class="co">// system LEDs</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>  RXD<span class="op">,</span>        <span class="co">// UART receive</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> TXD         <span class="co">// UART transmit</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span>    clk<span class="op">;</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span>    resetn<span class="op">;</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>   Memory RAM<span class="op">(</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>      .clk<span class="op">(</span>clk<span class="op">),</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>      .mem_addr<span class="op">(</span>mem_addr<span class="op">),</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>      .mem_rdata<span class="op">(</span>mem_rdata<span class="op">),</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>      .mem_rstrb<span class="op">(</span>mem_rstrb<span class="op">)</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_addr<span class="op">;</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_rdata<span class="op">;</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> mem_rstrb<span class="op">;</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> x1<span class="op">;</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>   Processor CPU<span class="op">(</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>      .clk<span class="op">(</span>clk<span class="op">),</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>      .resetn<span class="op">(</span>resetn<span class="op">),</span>       </span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>      .mem_addr<span class="op">(</span>mem_addr<span class="op">),</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>      .mem_rdata<span class="op">(</span>mem_rdata<span class="op">),</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>      .mem_rstrb<span class="op">(</span>mem_rstrb<span class="op">),</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>      .x1<span class="op">(</span>x1<span class="op">)</span>        </span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> LEDS <span class="op">=</span> x1<span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Gearbox and reset circuitry.</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>   Clockworks #<span class="op">(</span></span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>     .SLOW<span class="op">(</span><span class="dv">19</span><span class="op">)</span> <span class="co">// Divide clock frequency by 2^19</span></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>   <span class="op">)</span> CW <span class="op">(</span></span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>     .CLK<span class="op">(</span>CLK<span class="op">),</span></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a>     .RESET<span class="op">(</span>RESET<span class="op">),</span></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>     .clk<span class="op">(</span>clk<span class="op">),</span></span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a>     .resetn<span class="op">(</span>resetn<span class="op">)</span></span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> TXD  <span class="op">=</span> <span class="bn">1&#39;b0</span><span class="op">;</span> <span class="co">// not used for now   </span></span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>Now you can run <a href="step11.v">step11.v</a> in the simulator. As
expected, it does the same thing as in the previous step (counts on the
LEDs from 0 to 31 and stops). What about running it on the device ? Wow,
even worse, 1341 LUTs (and we only got 1280 of them on the IceStick). So
let us shrink our code to make it fit !</p>
<h2 id="step-12-size-optimization-the-incredible-shrinking-core.">Step
12: Size optimization: the Incredible Shrinking Core.</h2>
<p><em>Tribute to “the Incredible Shrinking Man” classic movie</em></p>
<p>There are many things we can do for shrinking this core. Let us first
take a look at the ALU. It can compute addition, subtraction, and
comparisons. Can’t we reuse the result of subtraction for comparisons ?
Sure we can, but to do that we need to compute a 33 bits subtraction,
and test the sign bit. Matthias Koch (<span class="citation"
data-cites="Mecrisp">@Mecrisp</span>) explained me this trick, that is
also used in swapforth/J1 (another small RISC core that works on the
IceStick). The 33 bits subtract is written as follows:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> aluMinus <span class="op">=</span> <span class="op">{</span><span class="bn">1&#39;b0</span><span class="op">,</span>aluIn1<span class="op">}</span> <span class="op">-</span> <span class="op">{</span><span class="bn">1&#39;b0</span><span class="op">,</span>aluIn2<span class="op">};</span></span></code></pre></div>
<p>if you want to know what <code>A-B</code> does in Verilog, it
corresponds to <code>A+~B+1</code> (negate all the bits of B before
adding, and add 1), it is how two’s complement subtraction works. For
instance, take <code>4'b0000 - 4'b0001</code>, the result is
<code>-1</code>, encoded as <code>4'b1111</code>. It is computed as
follows by the formula: <code>4'b0000 + ~4'b0001 + 1</code> =
<code>4'b0000 + 4'b1110 + 1</code> = <code>4'b1111</code>. So we will
keep the following expression (we could have kept the simpler form
above, but it is interesting to be aware of what happens under the
scene):</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">32</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> aluMinus <span class="op">=</span> <span class="op">{</span><span class="bn">1&#39;b1</span><span class="op">,</span> <span class="op">~</span>aluIn2<span class="op">}</span> <span class="op">+</span> <span class="op">{</span><span class="bn">1&#39;b0</span><span class="op">,</span>aluIn1<span class="op">}</span> <span class="op">+</span> <span class="bn">33&#39;b1</span><span class="op">;</span></span></code></pre></div>
<p>Then we can create the wires for the three tests (this saves three
32-bit adders):</p>
<pre><code>   wire        EQ  = (aluMinus[31:0] == 0);
   wire        LTU = aluMinus[32];
   wire        LT  = (aluIn1[31] ^ aluIn2[31]) ? aluIn1[31] : aluMinus[32];</code></pre>
<ul>
<li>The first one, <code>EQ</code>, goes high when <code>aluIn1</code>
and <code>aluIn2</code> have the same value, or
<code>aluMinus == 0</code> (no need to test the 33-rd bit)</li>
<li>the second one, <code>LTU</code>, corresponds to unsigned
comparison. It is given by the sign bit of our 33-bits subtraction.</li>
<li>for the third one, there are two cases: if the signs differ, then
<code>LT</code> goes high if <code>aluIn1</code> is negative, else it is
given by the sign bit of our 33-bits subtraction.</li>
</ul>
<p>Of course, we still need one adder for addition:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> aluPlus <span class="op">=</span> aluIn1 <span class="op">+</span> aluIn2<span class="op">;</span></span></code></pre></div>
<p>Then, <code>aluOut</code> is computed as follows:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>  aluOut<span class="op">;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span>*<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span><span class="op">(</span>funct3<span class="op">)</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b000</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>funct7<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">&amp;</span> instr<span class="op">[</span><span class="dv">5</span><span class="op">])</span> <span class="op">?</span> aluMinus<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span> aluPlus<span class="op">;</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b001</span><span class="op">:</span> aluOut <span class="op">=</span> aluIn1 <span class="op">&lt;&lt;</span> shamt<span class="op">;;</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b010</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">{</span><span class="bn">31&#39;b0</span><span class="op">,</span> LT<span class="op">};</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b011</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">{</span><span class="bn">31&#39;b0</span><span class="op">,</span> LTU<span class="op">};</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b100</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">^</span> aluIn2<span class="op">);</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b101</span><span class="op">:</span> aluOut <span class="op">=</span> funct7<span class="op">[</span><span class="dv">5</span><span class="op">]?</span> <span class="op">(</span><span class="dt">$signed</span><span class="op">(</span>aluIn1<span class="op">)</span> <span class="op">&gt;&gt;&gt;</span> shamt<span class="op">)</span> <span class="op">:</span> </span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>             <span class="op">(</span><span class="dt">$signed</span><span class="op">(</span>aluIn1<span class="op">)</span> <span class="op">&gt;&gt;</span> shamt<span class="op">);</span> </span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b110</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">|</span> aluIn2<span class="op">);</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b111</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">&amp;</span> aluIn2<span class="op">);</span> </span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">endcase</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>Let us try on the IceStick. Yes ! 1167 LUTs, it fits ! But it is not
a good reason to stop there, there are still several opportunities to
shrink space. Let us take a look at <code>takeBranch</code>, can’t we
reuse the <code>EQ</code>,<code>LT</code>,<code>LTU</code> signals we
just created ? Sure we can:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> takeBranch<span class="op">;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span>*<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span><span class="op">(</span>funct3<span class="op">)</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b000</span><span class="op">:</span> takeBranch <span class="op">=</span> EQ<span class="op">;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b001</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="op">!</span>EQ<span class="op">;</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b100</span><span class="op">:</span> takeBranch <span class="op">=</span> LT<span class="op">;</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b101</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="op">!</span>LT<span class="op">;</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b110</span><span class="op">:</span> takeBranch <span class="op">=</span> LTU<span class="op">;</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b111</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="op">!</span>LTU<span class="op">;</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">default</span><span class="op">:</span> takeBranch <span class="op">=</span> <span class="bn">1&#39;b0</span><span class="op">;</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">endcase</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>For this to work, we also need to make sure that <code>rs2</code> is
routed to the second ALU input also for branches:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> aluIn2 <span class="op">=</span> isALUreg <span class="op">|</span> isBranch <span class="op">?</span> rs2 <span class="op">:</span> Iimm<span class="op">;</span></span></code></pre></div>
<p>What does it give on the device ? 1094 LUTs, not that bad, but let us
continue… The jump target for <code>JALR</code> is
<code>rs1+Iimm</code>, and we created an adder especially for that, it
is stupid because the ALU already computes that. OK let us reuse it:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> nextPC <span class="op">=</span> <span class="op">((</span>isBranch <span class="op">&amp;&amp;</span> takeBranch<span class="op">)</span> <span class="op">||</span> isJAL<span class="op">)</span> <span class="op">?</span> PCplusImm  <span class="op">:</span>         </span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>                    isJALR                              <span class="op">?</span> <span class="op">{</span>aluPlus<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">1</span><span class="op">],</span><span class="bn">1&#39;b0</span><span class="op">}:</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>                    PCplus4<span class="op">;</span></span></code></pre></div>
<p>How do we stand now ? 1030 LUTs. And it is not finished: what eats-up
the largest number of LUTs is the shifter, and we have three of them in
the ALU (one for left shifts, one for logical right shifts and one for
arithmetic right shifts). By another sorcerer’s trick indicated by by
Matthias Koch (<span class="citation"
data-cites="mecrisp">@mecrisp</span>), it is possible to merge the two
right shifts, by creating a 33 bits shifter with the additional bit set
to 0 or 1 depending on input’s bit31 and on whether it is a logical
shift or an arithmetic shift.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> shifter <span class="op">=</span> </span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>               <span class="dt">$signed</span><span class="op">({</span>instr<span class="op">[</span><span class="dv">30</span><span class="op">]</span> <span class="op">&amp;</span> aluIn1<span class="op">[</span><span class="dv">31</span><span class="op">],</span> shifter_in<span class="op">})</span> <span class="op">&gt;&gt;&gt;</span> aluIn2<span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">];</span></span></code></pre></div>
<p>Even better, Matthias told me it is possible to use in fact a single
shifter, by flipping the input and flipping the output if it is a left
shift:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> shifter_in <span class="op">=</span> <span class="op">(</span>funct3 <span class="op">==</span> <span class="bn">3&#39;b001</span><span class="op">)</span> <span class="op">?</span> flip32<span class="op">(</span>aluIn1<span class="op">)</span> <span class="op">:</span> aluIn1<span class="op">;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> leftshift <span class="op">=</span> flip32<span class="op">(</span>shifter<span class="op">);</span></span></code></pre></div>
<p>The ALU then looks like that:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>  aluOut<span class="op">;</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span>*<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span><span class="op">(</span>funct3<span class="op">)</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b000</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>funct7<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">&amp;</span> instr<span class="op">[</span><span class="dv">5</span><span class="op">])</span> <span class="op">?</span> aluMinus<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span> aluPlus<span class="op">;</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b001</span><span class="op">:</span> aluOut <span class="op">=</span> leftshift<span class="op">;</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b010</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">{</span><span class="bn">31&#39;b0</span><span class="op">,</span> LT<span class="op">};</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b011</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">{</span><span class="bn">31&#39;b0</span><span class="op">,</span> LTU<span class="op">};</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b100</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">^</span> aluIn2<span class="op">);</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b101</span><span class="op">:</span> aluOut <span class="op">=</span> shifter<span class="op">;</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b110</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">|</span> aluIn2<span class="op">);</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    <span class="bn">3&#39;b111</span><span class="op">:</span> aluOut <span class="op">=</span> <span class="op">(</span>aluIn1 <span class="op">&amp;</span> aluIn2<span class="op">);</span> </span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">endcase</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>Where do we stand now ? 887 LUTs my friend !</p>
<p><em>Note 1</em> well, in fact one can gain even more space with the
shifter, by shifting 1 single bit at each clock. The ALU then becomes a
little bit more complicated (multi-cycle), but much much smaller
(Femtorv32-quark uses this trick). We will see that later.</p>
<p><em>Note 2</em> with a multi-cycle ALU, we could also have a single
33-bits adder, and compute subtractions in three cycles, by separating
the computation of <code>~aluIn2</code>, <code>aluIn1+(~aluIn2)</code>
and <code>aluIn1+(~aluIn2)+1</code>.</p>
<p>Before then, another easy win is factoring the adder used for address
computation, as follows:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> PCplusImm <span class="op">=</span> PC <span class="op">+</span> <span class="op">(</span> instr<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">?</span> Jimm<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>                  instr<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">?</span> Uimm<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>                             Bimm<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">);</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> PCplus4 <span class="op">=</span> PC<span class="op">+</span><span class="dv">4</span><span class="op">;</span></span></code></pre></div>
<p>Then these two adders can be used by both <code>nextPC</code> and
<code>writeBackData</code>:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> writeBackData <span class="op">=</span> <span class="op">(</span>isJAL <span class="op">||</span> isJALR<span class="op">)</span> <span class="op">?</span> <span class="op">(</span>PCplus4<span class="op">)</span> <span class="op">:</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>              <span class="op">(</span>isLUI<span class="op">)</span> <span class="op">?</span> Uimm <span class="op">:</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>              <span class="op">(</span>isAUIPC<span class="op">)</span> <span class="op">?</span> PCplusImm <span class="op">:</span> </span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>              aluOut<span class="op">;</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> writeBackEn <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> EXECUTE <span class="op">&amp;&amp;</span> <span class="op">!</span>isBranch<span class="op">);</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> nextPC <span class="op">=</span> <span class="op">(</span>isBranch <span class="op">&amp;&amp;</span> takeBranch <span class="op">||</span> isJAL<span class="op">)</span> <span class="op">?</span> PC<span class="op">+</span>Imm  <span class="op">:</span>          </span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>                    isJALR                   <span class="op">?</span> <span class="op">{</span>aluPlus<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">1</span><span class="op">],</span><span class="bn">1&#39;b0</span><span class="op">}</span> <span class="op">:</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>                    PCplus<span class="op">;</span></span></code></pre></div>
<p>The verdict ? 839 LUTs (we have gained another 50 LUTs or so…). There
is still room for gaining more LUTs (by using a multi-cycle ALU for
shifts, and by using a smaller number of bits for address computation),
but we’ll keep that for later, since we have now enough room on the
device for the next steps.</p>
<h2
id="step-13-subroutines-version-1-using-plain-risc-v-instructions">Step
13: subroutines (version 1, using plain RISC-V instructions)</h2>
<p>OK, so now we have an (uncomplete) RISC-V processor, a SOC, both fit
on the device. Remember, we are approaching the end, only 8 instructions
to go (5 Load variants, 3 Store variants).</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>ALUreg</th>
<th>ALUimm</th>
<th>Jump</th>
<th>Branch</th>
<th>LUI</th>
<th>AUIPC</th>
<th>Load</th>
<th>Store</th>
<th>SYSTEM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[*] 10</td>
<td>[*] 9</td>
<td>[*] 2</td>
<td>[ *] 6</td>
<td>[*]</td>
<td>[*]</td>
<td>[ ] 5</td>
<td>[ ] 3</td>
<td>[*] 1</td>
</tr>
</tbody>
</table>
<p>Before attacking them, let us learn a bit more on RISC-V assembly,
and function calls. Up to now, we have used a gearbox to slow down the
CPU in such a way we can observe it executing our programs. Could’nt we
implement a <code>wait</code> function instead and call it ? Let us see
how to do that.</p>
<p>First thing to do is to remove the <code>#(.SLOW(nnn))</code>
parameter in the <code>Clockworks</code> instanciation:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>   Clockworks CW<span class="op">(</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>     .CLK<span class="op">(</span>CLK<span class="op">),</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>     .RESET<span class="op">(</span>RESET<span class="op">),</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>     .clk<span class="op">(</span>clk<span class="op">),</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>     .resetn<span class="op">(</span>resetn<span class="op">)</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span></code></pre></div>
<p>this no longer generates a gearbox and directly wires the
<code>CLK</code> signal of the board to the internal <code>clk</code>
signal used by our design.</p>
<p>OK, so now we need to see two different things: - how to write a
function that waits for some time - how to call it</p>
<p><em>Wait a minute</em> you are talking about function calls, but we
do not have <code>Load</code> / <code>Store</code> instructions. We
won’t be able to push the return address on the stack (because we cannot
read/write memory, and the stack is in memory !), so how is it possible
?</p>
<p>There would many possible ways of using RISC-V instructions to
implement function calls. To make sure everybody uses the same
convention, there is an <strong>application binary interface</strong>
that defines how to call functions, how to pass parameters, and which
register does what. See <a
href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">this
document</a> for more details.</p>
<p><strong>Calling a function</strong> In this document, we learn that
for calling a function, the return address will be stored in
<code>x1</code>. Hence one can call a function using
<code>JAL(x1,offset)</code> where <code>offset</code> is the (signed)
difference between the program counter and the address of the function
to be called. This works provided the offset fits in 20 bits (Jimm
format). <em>Note</em>: for function that are further away, one can use
a combination of <code>AUIPC</code> and <code>JALR</code> to reach an
arbitrary offset.</p>
<p><strong>Returning from a function</strong> is done by jumping to the
address stored in <code>x1</code>, which can be done by
<code>JALR(x0,x1,0)</code>.</p>
<p><strong>Function arguments and return value</strong>: The first 6
function arguments are passed through
<code>x10</code>..<code>x16</code>, and the return value is passed
through <code>x10</code> (it overwrites the first function
argument).</p>
<p>That’s interesting, even though we do not have
<code>Load</code>/<code>Store</code>, we can write programs with
functions, but we cannot write functions that call other functions,
because this requires saving <code>x1</code> to the stack (well in fact
nothing forbids us from doing that by saving <code>x1</code> in another
register but then it would quickly become a mess, so we won’t do
that).</p>
<p>One little thing: we have just learnt that in the ABI,
<code>x1</code> is used to store the return address of functions. Up to
know we have wired it to the LEDs. Since we are going now to comply with
the ABI, we need to chose another register instead. From now,
<code>x10</code> will be wired to the LEDs.</p>
<p>OK, so now we have everything we need to write yet another version of
the blinky ! Let us chose a <code>slow_bit</code> constant, wire a
<code>wait</code> function that counts to <code>2^slow_bit</code>, and
call it to slow-down our blinky:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`ifdef BENCH</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> slow_bit<span class="op">=</span><span class="dv">15</span><span class="op">;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="ot">`else</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> slow_bit<span class="op">=</span><span class="dv">19</span><span class="op">;</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="ot">`endif</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="ot">`include </span><span class="fl">&quot;riscv_assembly.v&quot;</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> L0_   <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> wait_ <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> L1_   <span class="op">=</span> <span class="dv">28</span><span class="op">;</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>x10<span class="op">,</span>x0<span class="op">,</span>x0<span class="op">);</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>L0_<span class="op">);</span> </span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>x10<span class="op">,</span>x10<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>      JAL<span class="op">(</span>x1<span class="op">,</span>LabelRef<span class="op">(</span>wait_<span class="op">));</span> <span class="co">// call(wait_)</span></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>      JAL<span class="op">(</span>zero<span class="op">,</span>LabelRef<span class="op">(</span>L0_<span class="op">));</span> <span class="co">// jump(l0_)</span></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>      EBREAK<span class="op">();</span> <span class="co">// I keep it systematically</span></span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">// here in case I change the program.</span></span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>wait_<span class="op">);</span></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>x11<span class="op">,</span>x0<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a>      SLLI<span class="op">(</span>x11<span class="op">,</span>x11<span class="op">,</span>slow_bit<span class="op">);</span></span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>L1_<span class="op">);</span></span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>x11<span class="op">,</span>x11<span class="op">,-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a>      BNE<span class="op">(</span>x11<span class="op">,</span>x0<span class="op">,</span>LabelRef<span class="op">(</span>L1_<span class="op">));</span></span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true" tabindex="-1"></a>      JALR<span class="op">(</span>x0<span class="op">,</span>x1<span class="op">,</span><span class="dv">0</span><span class="op">);</span>      </span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true" tabindex="-1"></a>      endASM<span class="op">();</span></span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-34"><a href="#cb56-34" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb56-35"><a href="#cb56-35" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>mem_rstrb<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb56-36"><a href="#cb56-36" aria-hidden="true" tabindex="-1"></a>         mem_rdata <span class="op">&lt;=</span> MEM<span class="op">[</span>mem_addr<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">2</span><span class="op">]];</span></span>
<span id="cb56-37"><a href="#cb56-37" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb56-38"><a href="#cb56-38" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb56-39"><a href="#cb56-39" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>Try <a href="step13.v">step13.v</a> in simulation and on the
device.</p>
<p><strong>Try this</strong> Knight-driver blinky, with one routine for
going from left to right, another routine for going from right to left,
and the wait routine. <em>Hint</em> you will need to save
<code>x1</code> to another register.</p>
<h2
id="step-14-subroutines-version-2-using-risc-v-abi-and-pseudo-instructions">Step
14: subroutines (version 2, using RISC-V ABI and
pseudo-instructions)</h2>
<p>With the ABI, we have a standard way of writing programs, but there
are many things to remember: - all RISC-V registers are the same, but
with the ABI, we need to use certain registers for certain tasks
(<code>x1</code> for return address, <code>x10</code>..<code>x16</code>
for function parameters, etc…); - calling a function is implemented
using <code>JAL</code> or <code>AUIPC</code> and <code>JALR</code>, and
returning from a function is implemented using <code>JALR</code>.</p>
<p>On a CISC processor, there are often special functions for calling
functions (<code>CALL</code>) and for returning from a function
(<code>RET</code>), and registers are often specialized (function return
address, stack pointer, function parameters). This makes programmer’s
life easier because there is less to remember. There is no reason not
doing the same for a RISC processor ! Let us pretend that the register
are different and give them different names (or aliases). These names
are listed <a
href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#general-registers">here</a>.</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 8%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>ABI name</th>
<th>name</th>
<th>usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>zero</code></td>
<td><code>x0</code></td>
<td>read:0 write:ignored</td>
</tr>
<tr class="even">
<td><code>ra</code></td>
<td><code>x1</code></td>
<td>return address</td>
</tr>
<tr class="odd">
<td><code>t0</code>…<code>t6</code></td>
<td>…</td>
<td>temporary registers</td>
</tr>
<tr class="even">
<td><code>fp</code>,<code>s0</code>…<code>s11</code></td>
<td>…</td>
<td>saved registers, <code>fp</code>=<code>so</code>: frame pointer</td>
</tr>
<tr class="odd">
<td><code>a0</code>…<code>a7</code></td>
<td>…</td>
<td>function parameters and return value (<code>a0</code>)</td>
</tr>
<tr class="even">
<td><code>sp</code></td>
<td><code>x2</code></td>
<td>stack pointer</td>
</tr>
<tr class="odd">
<td><code>gp</code></td>
<td><code>x3</code></td>
<td>global pointer</td>
</tr>
</tbody>
</table>
<p>Saved registers (<code>s0</code>, … <code>s11</code>) are supposed to
be left untouched or saved/restored by functions. You can put your local
variables there. If you write a function, you are supposed to push the
ones you use on the stack and pop them before returning.</p>
<p>For all the other registers, you cannot expect them to be preserved
through function calls.</p>
<p>The global pointer <code>gp</code> can be used as a “shortcut” to
reach memory areas that are far away in 1 instruction. We will see that
later (once we have <code>Load</code> and <code>Store</code>).</p>
<p>In our VERILOG assembler <a
href="riscv_assembly.v">riscv_assembly.v</a>, we just need to declare
these aliases for register names:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> zero <span class="op">=</span> x0<span class="op">;</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> ra   <span class="op">=</span> x1<span class="op">;</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> sp   <span class="op">=</span> x2<span class="op">;</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> gp   <span class="op">=</span> x3<span class="op">;</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> t4   <span class="op">=</span> x29<span class="op">;</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> t5   <span class="op">=</span> x30<span class="op">;</span>      </span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> t6   <span class="op">=</span> x31<span class="op">;</span>   </span></code></pre></div>
<p>Besides these names, there are also <em>pseudo-instructions</em> for
common tasks, such as: | pseudo-instruction | action |
|———————–|————————————–| | <code>LI(rd,imm)</code> | loads a 32-bits
number in a register | | <code>CALL(offset)</code> | calls a function |
| <code>RET()</code> | return from a function | | <code>MV(rd,rs)</code>
| equivalent to <code>ADD(rd,rs,zero)</code> | | <code>NOP()</code> |
equivalent to <code>ADD(zero,zero,zero)</code> | |
<code>J(offset)</code> | equivalent to <code>JAL(zero,offset)</code> | |
<code>BEQZ(rd1,offset)</code> | equivalent to
<code>BEQ(rd1,x0,offset)</code> | | <code>BNEZ(rd1,offset)</code> |
equivalent to <code>BNE(rd1,x0,offset)</code> | |
<code>BGT(rd1,rd2,offset)</code> | equivalent to
<code>BLT(rd2,rd1,offset)</code> |</p>
<p>If the constant in the [-2048,2047] range, <code>LI</code> is
implemented using <code>ADDI(rd,x0,imm)</code>, else it uses a
combination of <code>LUI</code> and <code>ADDI</code> (if you want to
know how it works, see this <a
href="https://stackoverflow.com/questions/50742420/risc-v-build-32-bit-constants-with-lui-and-addi">stackoverflow
answer</a>, there are tricky details about sign expansion).</p>
<p>Using ABI register names and pseudo-instructions, our program becomes
as follows:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> L0_   <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> wait_ <span class="op">=</span> <span class="dv">24</span><span class="op">;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> L1_   <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>L0_<span class="op">);</span> </span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>a0<span class="op">,</span>a0<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>wait_<span class="op">));</span> </span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>      J<span class="op">(</span>LabelRef<span class="op">(</span>L0_<span class="op">));</span> </span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>      EBREAK<span class="op">();</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>wait_<span class="op">);</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>      SLLI<span class="op">(</span>a1<span class="op">,</span>a1<span class="op">,</span>slow_bit<span class="op">);</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>L1_<span class="op">);</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>a1<span class="op">,</span>a1<span class="op">,-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>      BNEZ<span class="op">(</span>a1<span class="op">,</span>LabelRef<span class="op">(</span>L1_<span class="op">));</span></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>      RET<span class="op">();</span></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>      endASM<span class="op">();</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>It does not make a huge difference, but in longer programs, it
improves legibility by showing the intent of the programmer (this one is
a function, that one is a jump to a label etc…). Without it, since
everything looks like the same, reading a program is more difficult.</p>
<p>It is quite funny: the RISC-V standard has a super-simple instruction
set, but programming with it is not that easy, so the ABI pretends that
the instruction set is more complicated, like a CISC processor, and this
makes programmer’s life easier. It also ensures that a function written
by a programmer can be called from a function written by another
programmer, possibly in a different language. We will see later how to
use GNU assembler and C compiler to compile programs for our CPU. But
before playing with software and toolchains, remember, we still have 8
instructions to implement in hardware (5 <code>Load</code> variants and
3 <code>Store</code> variants).</p>
<p><strong>Try this</strong> invent (or copy it from <a
href="https://github.com/riscv-collab/riscv-gcc/blob/5964b5cd72721186ea2195a7be8d40cfe6554023/libgcc/config/riscv/muldi3.S">somewhere
else</a>) a routine to multiply two numbers, test it on various inputs
in simulation, and on the device.</p>
<h2 id="step-15-load">Step 15: Load</h2>
<p>Let us see now how to implement load instructions. There are 5
different instructions:</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Instruction</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LW(rd,rs1,imm)</td>
<td>Load word at address (rs1+imm) into rd</td>
</tr>
<tr class="even">
<td>LBU(rd,rs1,imm)</td>
<td>Load byte at address (rs1+imm) into rd</td>
</tr>
<tr class="odd">
<td>LHU(rd,rs1,imm)</td>
<td>Load half-word at address (rs1+imm) into rd</td>
</tr>
<tr class="even">
<td>LB(rd,rs1,imm)</td>
<td>Load byte at address (rs1+imm) into rd then sign extend</td>
</tr>
<tr class="odd">
<td>LH(rd,rs1,imm)</td>
<td>Load half-word at address (rs1+imm) into rd then sign extend</td>
</tr>
</tbody>
</table>
<p><em>Note</em> addresses are aligned on word boundaries for
<code>LW</code> (multiple of 4 bytes) and halfword boundaries for
<code>LH</code>,<code>LHU</code> (multiple of 2 bytes). It is a good
thing, it makes things much easier for us…</p>
<p>But we still have some work to do ! First, some circuitry that
determines the loaded value (that we will call
<code>LOAD_data</code>).</p>
<p>As you can see, we got instructions for loading words, half-words and
bytes, and instructions that load half-words and bytes exist in two
versions: - <code>LBU</code>,<code>LHU</code> that load a byte,halfword
in the LSBs of <code>rd</code> - <code>LB</code>,<code>LH</code> that
load a byte,halfword in the LSBs of <code>rd</code> then do sign
extensin:</p>
<p>For instance, imagine a sign byte with the value <code>-1</code>,
that is <code>8'b11111111</code>, loading it in a 32-bit register with
<code>LBU</code> will result in
<code>32'b0000000000000000000000011111111</code>, whereas loading it
with <code>LB</code> will result in
<code>32'b11111111111111111111111111111111</code>, that is, the 32-bits
version of <code>-1</code>.</p>
<p>So we got a “two-dimensional” array of cases (whether we load a byte,
halfword, word, and whether we do sign extension or not). Well, in fact
it is even more complicated. Remember, our memory is structured into
words, so when we load a byte, we need to know which one it is (among
4), and when we load a halfword, we need to know which one it is (among
2). This can be done by examining the 2 LSBs of the address of the data
to be loaded (<code>rs1 + Iimm</code>):</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> loadstore_addr <span class="op">=</span> rs1 <span class="op">+</span> Iimm<span class="op">;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> LOAD_halfword <span class="op">=</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>           loadstore_addr<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">?</span> mem_rdata<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">16</span><span class="op">]</span> <span class="op">:</span> mem_rdata<span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span>  <span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> LOAD_byte <span class="op">=</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>           loadstore_addr<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">?</span> LOAD_halfword<span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">8</span><span class="op">]</span> <span class="op">:</span> LOAD_halfword<span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">];</span></span></code></pre></div>
<p>OK, so now we need to select among <code>mem_rdata</code>
(<code>LW</code>), <code>LOAD_halfword</code>
(<code>LH</code>,<code>LHU</code>) and <code>LOAD_byte</code>
(<code>LB</code>,<code>LBU</code>). Examining the table in the <a
href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V
reference manual</a> page 130, this is determined by the two LSBs of
<code>funct3</code>:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> mem_byteAccess     <span class="op">=</span> funct3<span class="op">[</span><span class="dv">1</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">2&#39;b00</span><span class="op">;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> mem_halfwordAccess <span class="op">=</span> funct3<span class="op">[</span><span class="dv">1</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">2&#39;b01</span><span class="op">;</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> LOAD_data <span class="op">=</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>         mem_byteAccess <span class="op">?</span> LOAD_byte     <span class="op">:</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>     mem_halfwordAccess <span class="op">?</span> LOAD_halfword <span class="op">:</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>                          mem_rdata     <span class="op">;</span></span></code></pre></div>
<p>Now we need to insert sign expansion into this expression. The value
to be written in the MSBs of <code>rd</code>, <code>LOAD_sign</code>,
depends on both whether the instruction does sign expansion
(<code>LB</code>,<code>LH</code>), characterized by
<code>funct3[2]=0</code>, and the MSB of the loaded value:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> LOAD_sign <span class="op">=</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>funct3<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">&amp;</span> <span class="op">(</span>mem_byteAccess <span class="op">?</span> LOAD_byte<span class="op">[</span><span class="dv">7</span><span class="op">]</span> <span class="op">:</span> LOAD_halfword<span class="op">[</span><span class="dv">15</span><span class="op">]);</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> LOAD_data <span class="op">=</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>         mem_byteAccess <span class="op">?</span> <span class="op">{{</span><span class="dv">24</span><span class="op">{</span>LOAD_sign<span class="op">}},</span>     LOAD_byte<span class="op">}</span> <span class="op">:</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>     mem_halfwordAccess <span class="op">?</span> <span class="op">{{</span><span class="dv">16</span><span class="op">{</span>LOAD_sign<span class="op">}},</span> LOAD_halfword<span class="op">}</span> <span class="op">:</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>                          mem_rdata <span class="op">;</span></span></code></pre></div>
<p>Pfiuuuu, it was a bit painful, but in the end it is not too
complicated. My initial design was much more complicated, but Matthias
Koch (<span class="citation" data-cites="mecrisp">@mecrisp</span>)
simplified it a lot, resulting in the (reasonably easy to understand)
design above.</p>
<p>We are not completely done though, now we need to modify the state
machine. It will have two additional states, <code>LOAD</code> and
<code>WAIT_DATA</code>:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> FETCH_INSTR <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> WAIT_INSTR  <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> FETCH_REGS  <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> EXECUTE     <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> LOAD        <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> WAIT_DATA   <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">2</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> state <span class="op">=</span> FETCH_INSTR<span class="op">;</span></span></code></pre></div>
<p><em>Note 1</em> we could do with a smaller number of states, but for
now our goal is to have something that works and that is as easy to
understand as possible. We will see later how to simplify the state
machine. <em>Note 2</em> do not forget to check that <code>state</code>
has the required number of bits ! (<code>reg [2:0] state</code> instead
of <code>reg [1:0] state</code> as before !!). Then the new states are
plugged in as follows:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>     ...</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>       <span class="dv">EXECUTE:</span> <span class="kw">begin</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span><span class="op">(!</span>isSYSTEM<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>         PC <span class="op">&lt;=</span> nextPC<span class="op">;</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">end</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> isLoad <span class="op">?</span> LOAD <span class="op">:</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>       <span class="dv">LOAD:</span> <span class="kw">begin</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> WAIT_DATA<span class="op">;</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>       <span class="dv">WAIT_DATA:</span> <span class="kw">begin</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>     ...</span></code></pre></div>
<p>And finally, the signals <code>mem_addr</code> (with the address to
be read) and <code>mem_rstrb</code> (that goes high whenever the
processor wants to read data) are driven as follows:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_addr <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> WAIT_INSTR <span class="op">||</span> state <span class="op">==</span> FETCH_INSTR<span class="op">)</span> <span class="op">?</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>             <span class="dv">PC :</span> loadstore_addr <span class="op">;</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_rstrb <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> FETCH_INSTR <span class="op">||</span> state <span class="op">==</span> LOAD<span class="op">);</span></span></code></pre></div>
<p>Let us test now our new instructions with the following program:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> L0_   <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> wait_ <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span> L1_   <span class="op">=</span> <span class="dv">40</span><span class="op">;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s0<span class="op">,</span><span class="dv">0</span><span class="op">);</span>   </span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s1<span class="op">,</span><span class="dv">16</span><span class="op">);</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>L0_<span class="op">);</span> </span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>      LB<span class="op">(</span>a0<span class="op">,</span>s0<span class="op">,</span><span class="dv">400</span><span class="op">);</span> <span class="co">// LEDs are plugged on a0 (=x10)</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>wait_<span class="op">));</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>s0<span class="op">,</span>s0<span class="op">,</span><span class="dv">1</span><span class="op">);</span> </span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>      BNE<span class="op">(</span>s0<span class="op">,</span>s1<span class="op">,</span> LabelRef<span class="op">(</span>L0_<span class="op">));</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>      EBREAK<span class="op">();</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>wait_<span class="op">);</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>t0<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>      SLLI<span class="op">(</span>t0<span class="op">,</span>t0<span class="op">,</span>slow_bit<span class="op">);</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>L1_<span class="op">);</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>t0<span class="op">,</span>t0<span class="op">,-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>      BNEZ<span class="op">(</span>t0<span class="op">,</span>LabelRef<span class="op">(</span>L1_<span class="op">));</span></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>      RET<span class="op">();</span></span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>      endASM<span class="op">();</span></span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Note: index 100 (word address)</span></span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a>      <span class="co">//     corresponds to </span></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>      <span class="co">// address 400 (byte address)</span></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a>      MEM<span class="op">[</span><span class="dv">100</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="bn">8&#39;h4</span><span class="op">,</span> <span class="bn">8&#39;h3</span><span class="op">,</span> <span class="bn">8&#39;h2</span><span class="op">,</span> <span class="bn">8&#39;h1</span><span class="op">};</span></span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>      MEM<span class="op">[</span><span class="dv">101</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="bn">8&#39;h8</span><span class="op">,</span> <span class="bn">8&#39;h7</span><span class="op">,</span> <span class="bn">8&#39;h6</span><span class="op">,</span> <span class="bn">8&#39;h5</span><span class="op">};</span></span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a>      MEM<span class="op">[</span><span class="dv">102</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="bn">8&#39;hc</span><span class="op">,</span> <span class="bn">8&#39;hb</span><span class="op">,</span> <span class="bn">8&#39;ha</span><span class="op">,</span> <span class="bn">8&#39;h9</span><span class="op">};</span></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a>      MEM<span class="op">[</span><span class="dv">103</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="bn">8&#39;hff</span><span class="op">,</span> <span class="bn">8&#39;hf</span><span class="op">,</span> <span class="bn">8&#39;he</span><span class="op">,</span> <span class="bn">8&#39;hd</span><span class="op">};</span>            </span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>This program initializes some values in four words at address 400,
and loads them in <code>a10</code> in a loop. There is also a delay loop
(<code>wait</code> function) to let you see something, just as
before.</p>
<p><strong>Try this</strong> Run the program in simulation and on the
device. Test the other instructions. Do a programmable tinsel as in step
3.</p>
<p><strong>You are here !</strong> Just three instructions to go and we
will be done !</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>ALUreg</th>
<th>ALUimm</th>
<th>Jump</th>
<th>Branch</th>
<th>LUI</th>
<th>AUIPC</th>
<th>Load</th>
<th>Store</th>
<th>SYSTEM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[*] 10</td>
<td>[*] 9</td>
<td>[*] 2</td>
<td>[*] 6</td>
<td>[*]</td>
<td>[*]</td>
<td>[*] 5</td>
<td>[ ] 3</td>
<td>[*] 1</td>
</tr>
</tbody>
</table>
<h2 id="step-16-store">Step 16: Store</h2>
<p>We are approaching the end, but still some work to do, to implement
the following three instructions:</p>
<table>
<thead>
<tr class="header">
<th>Instruction</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SW(rs2,rs1,imm)</td>
<td>store rs2 at address rs1+imm</td>
</tr>
<tr class="even">
<td>SB(rs2,rs1,imm)</td>
<td>store 8 LSBs of rs2 at address rs1+imm</td>
</tr>
<tr class="odd">
<td>SH(rs2,rs1,imm)</td>
<td>store 16 LSBs of rs2 at address rs1+imm</td>
</tr>
</tbody>
</table>
<p>To do so, we will need to do three different things: - modify the
interface between the processor and the memory in such a way that the
processor can write to the memory - the memory is addressed by words.
Each write operation will modify a word. But <code>SB</code> and
<code>SH</code> need to be able to write individual bytes. Besides the
word to be written, we need to compute which byte of this word should be
effectively modified in memory (a 4-bits mask) - the state machine needs
to be modified.</p>
<p>The <code>Memory</code> module is modified as follows:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Memory <span class="op">(</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>             clk<span class="op">,</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>      <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_addr<span class="op">,</span>  </span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">output</span> <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_rdata<span class="op">,</span> </span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>         mem_rstrb<span class="op">,</span> </span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>      <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_wdata<span class="op">,</span> </span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">input</span>      <span class="op">[</span><span class="dv">3</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>  mem_wmask  </span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> MEM <span class="op">[</span><span class="dv">0</span><span class="op">:</span><span class="dv">255</span><span class="op">];</span> </span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">29</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> word_addr <span class="op">=</span> mem_addr<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>mem_rstrb<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>         mem_rdata <span class="op">&lt;=</span> MEM<span class="op">[</span>word_addr<span class="op">];</span></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>mem_wmask<span class="op">[</span><span class="dv">0</span><span class="op">])</span> MEM<span class="op">[</span>word_addr<span class="op">][</span> <span class="dv">7</span><span class="op">:</span><span class="dv">0</span> <span class="op">]</span> <span class="op">&lt;=</span> mem_wdata<span class="op">[</span> <span class="dv">7</span><span class="op">:</span><span class="dv">0</span> <span class="op">];</span></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>mem_wmask<span class="op">[</span><span class="dv">1</span><span class="op">])</span> MEM<span class="op">[</span>word_addr<span class="op">][</span><span class="dv">15</span><span class="op">:</span><span class="dv">8</span> <span class="op">]</span> <span class="op">&lt;=</span> mem_wdata<span class="op">[</span><span class="dv">15</span><span class="op">:</span><span class="dv">8</span> <span class="op">];</span></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>mem_wmask<span class="op">[</span><span class="dv">2</span><span class="op">])</span> MEM<span class="op">[</span>word_addr<span class="op">][</span><span class="dv">23</span><span class="op">:</span><span class="dv">16</span><span class="op">]</span> <span class="op">&lt;=</span> mem_wdata<span class="op">[</span><span class="dv">23</span><span class="op">:</span><span class="dv">16</span><span class="op">];</span></span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>mem_wmask<span class="op">[</span><span class="dv">3</span><span class="op">])</span> MEM<span class="op">[</span>word_addr<span class="op">][</span><span class="dv">31</span><span class="op">:</span><span class="dv">24</span><span class="op">]</span> <span class="op">&lt;=</span> mem_wdata<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">24</span><span class="op">];</span>    </span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>We have two new input signals: <code>mem_wdata</code>, a 32-bits
signal with the value to be written, and <code>mem_wmask</code> a 4-bits
signal that indicates which byte should be written.</p>
<p><em>Note</em> you may wonder how it is implemented in practice, in
particular how the masked write to memory is synthesized on the device.
BRAMs on most FPGAs directly support masked writes, through vendor’s
special primitives. Yosys has a (super smart) special step called
“technology mapping” that detects some patterns in the source VERILOG
file, and instances the vendor’s primitive best adapted to the usage. In
fact technology mapping was used before in our tutorial, to represent
the registers bank: at each cycle we read two registers,
<code>rs1</code> and <code>rs2</code>. In the IceStick, BRAMs can read a
single value at each clock, so to make it possible, yosys automatically
duplicates the register bank. Whenever a value is written to
<code>rd</code>, it is written to the two register banks:
<code>bank1[rdId] &lt;- writeBackValue; bank2[rdId] &lt;- writeBackValue;</code>,
and two different registers can be read at the same cycle, each one in
its own register bank
<code>rs1 &lt;- bank1[rs1Id]; rs2 &lt;- bank2[rs2Id;</code>. With the
magic of Yosys, you do not have to take care of this, it will
automatically select the best mapping for you (duplicated register bank,
single register bank with two read ports if target supports it, or even
array of flipflops with address decoder for larger FPGAs with many
LUTs). In our case, the IceStick has an Ice40HX1K, that has 8 kB of
BRAM, organized in 8 blocks of 1 kB each. Two of them are used for the
(duplicated) register bank, leaving 6 kB of BRAM that we use to
synthesize system RAM.</p>
<p>The <code>Processor</code> module is updated accordingly:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Processor <span class="op">(</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>         clk<span class="op">,</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>         resetn<span class="op">,</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>     mem_addr<span class="op">,</span> </span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>      mem_rdata<span class="op">,</span> </span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span>        mem_rstrb<span class="op">,</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>     mem_wdata<span class="op">,</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="op">[</span><span class="dv">3</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>      mem_wmask<span class="op">,</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> x10 <span class="op">=</span> <span class="dv">0</span>         </span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<p>(and everything is connected in the <code>SOC</code>).</p>
<p>Let us see now how to compute the word to be written and the mask.
The address where the value should be written is still
<code>rs1 + imm</code>, but the format of the immediate value is
different between <code>Load</code> (<code>Iimm</code>) and
<code>Store</code> (<code>Simm</code>):</p>
<pre><code>   wire [31:0] loadstore_addr = rs1 + (isStore ? Simm : Iimm);</code></pre>
<p>Now the data to be written depends on whether we write a byte, a
halfword or a word, and for bytes and halfwords, also depends on the 2
LSBs of the address. Interestingly, we do not need to test whether we
write a byte, a halfword or a word, because the write mask (see lated)
will ignore MSBs for byte and halfword write:</p>
<pre><code>   assign mem_wdata[ 7: 0] = rs2[7:0];
   assign mem_wdata[15: 8] = loadstore_addr[0] ? rs2[7:0]  : rs2[15: 8];
   assign mem_wdata[23:16] = loadstore_addr[1] ? rs2[7:0]  : rs2[23:16];
   assign mem_wdata[31:24] = loadstore_addr[0] ? rs2[7:0]  :
                 loadstore_addr[1] ? rs2[15:8] : rs2[31:24];</code></pre>
<p>And finally, the 4-bits write mask, that indicate which byte of
<code>mem_wdata</code> should be effectively written to memory. It is
determined as follows:</p>
<table>
<colgroup>
<col style="width: 52%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>write mask</th>
<th>Instruction</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>4'b1111</code></td>
<td><code>SW</code></td>
</tr>
<tr class="even">
<td><code>4'b0011</code> or <code>4'b1100</code></td>
<td><code>SH</code>, depending on <code>loadstore_addr[1]</code></td>
</tr>
<tr class="odd">
<td><code>4'b0001</code>, <code>4'b0010</code>, <code>4'b0100</code> or
<code>4'b1000</code></td>
<td><code>SB</code>, depending on <code>loadstore_addr[1:0]</code></td>
</tr>
</tbody>
</table>
<p>Deriving the expression is a bit painful. With Matthias Koch we ended
up with this one:</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">3</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> STORE_wmask <span class="op">=</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>          mem_byteAccess      <span class="op">?</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>                <span class="op">(</span>loadstore_addr<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">?</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>                  <span class="op">(</span>loadstore_addr<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">?</span> <span class="bn">4&#39;b1000</span> <span class="op">:</span> <span class="bn">4&#39;b0100</span><span class="op">)</span> <span class="op">:</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>                  <span class="op">(</span>loadstore_addr<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">?</span> <span class="bn">4&#39;b0010</span> <span class="op">:</span> <span class="bn">4&#39;b0001</span><span class="op">)</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>                    <span class="op">)</span> <span class="op">:</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>          mem_halfwordAccess <span class="op">?</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>                <span class="op">(</span>loadstore_addr<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">?</span> <span class="bn">4&#39;b1100</span> <span class="op">:</span> <span class="bn">4&#39;b0011</span><span class="op">)</span> <span class="op">:</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>              <span class="bn">4&#39;b1111</span><span class="op">;</span></span></code></pre></div>
<p>Let us now create additional states in the state machine:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> FETCH_INSTR <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> WAIT_INSTR  <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> FETCH_REGS  <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> EXECUTE     <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> LOAD        <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> WAIT_DATA   <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> STORE       <span class="op">=</span> <span class="dv">6</span><span class="op">;</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>       <span class="kw">case</span><span class="op">(</span>state<span class="op">)</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>           ...</span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>       <span class="dv">EXECUTE:</span> <span class="kw">begin</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span><span class="op">(!</span>isSYSTEM<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>         PC <span class="op">&lt;=</span> nextPC<span class="op">;</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a>          <span class="kw">end</span></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> isLoad  <span class="op">?</span> LOAD  <span class="op">:</span> </span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>               isStore <span class="op">?</span> STORE <span class="op">:</span> </span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a>               FETCH_INSTR<span class="op">;</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a>       <span class="dv">LOAD:</span> <span class="kw">begin</span></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> WAIT_DATA<span class="op">;</span></span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a>       <span class="dv">WAIT_DATA:</span> <span class="kw">begin</span></span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb71-28"><a href="#cb71-28" aria-hidden="true" tabindex="-1"></a>       <span class="dv">STORE:</span> <span class="kw">begin</span></span>
<span id="cb71-29"><a href="#cb71-29" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb71-30"><a href="#cb71-30" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb71-31"><a href="#cb71-31" aria-hidden="true" tabindex="-1"></a>     <span class="kw">endcase</span> </span>
<span id="cb71-32"><a href="#cb71-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb71-33"><a href="#cb71-33" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>The signals interfaced with the memory as driven as follows:</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_addr <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> WAIT_INSTR <span class="op">||</span> state <span class="op">==</span> FETCH_INSTR<span class="op">)</span> <span class="op">?</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>             <span class="dv">PC :</span> loadstore_addr <span class="op">;</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_rstrb <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> FETCH_INSTR <span class="op">||</span> state <span class="op">==</span> LOAD<span class="op">);</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_wmask <span class="op">=</span> <span class="op">{</span><span class="dv">4</span><span class="op">{(</span>state <span class="op">==</span> STORE<span class="op">)}}</span> <span class="op">&amp;</span> STORE_wmask<span class="op">;</span></span></code></pre></div>
<p>And, at last, a little thing: do not write back to register bank if
instruction is a <code>Store</code> !</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> writeBackEn <span class="op">=</span> <span class="op">(</span>state<span class="op">==</span>EXECUTE <span class="op">&amp;&amp;</span> <span class="op">!</span>isBranch <span class="op">&amp;&amp;</span> <span class="op">!</span>isStore <span class="op">&amp;&amp;</span> <span class="op">!</span>isLoad<span class="op">)</span> <span class="op">||</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>state<span class="op">==</span>WAIT_DATA<span class="op">)</span> <span class="op">;</span></span></code></pre></div>
<p><em>Note</em> The <code>!isLoad</code> term that prevents writing
<code>rd</code> during <code>EXECUTE</code> can be removed from the
condition, since <code>rd</code> will be overwritten right after during
the <code>WAIT_DATA</code>. It is there to have something easier to
understand with simulations.</p>
<p><strong>try this</strong> Run <a href="step16.v">step16.v</a> in
simulation and on the device. It copies 16 bytes from address 400 to
address 800, then displays the values of the copied bytes.</p>
<p><strong>You are here !</strong> Congratulations ! You have finished
implementing your first RV32I RISC-V core !</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 7%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>ALUreg</th>
<th>ALUimm</th>
<th>Jump</th>
<th>Branch</th>
<th>LUI</th>
<th>AUIPC</th>
<th>Load</th>
<th>Store</th>
<th>SYSTEM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[*] 10</td>
<td>[*] 9</td>
<td>[*] 2</td>
<td>[*] 6</td>
<td>[*]</td>
<td>[*]</td>
<td>[*] 5</td>
<td>[*] 3</td>
<td>[*] 1</td>
</tr>
</tbody>
</table>
<p><em>But wait a minute</em> for sure we have worked a lot to implement
a RISC-V core, but all what I can see know is just something that looks
like the stupid blinky at step 1 ! I want to see more !</p>
<p>To do so, we need to let our device communicate with the outside word
with more than 5 LEDs.</p>
<h2
id="step-17-memory-mapped-device---lets-do-much-more-than-a-blinky">Step
17: Memory-mapped device - let’s do (much) more than a blinky !</h2>
<p>Now the idea is to add devices to our SOC. We already have LEDs, that
are plugged to register <code>a0</code> (<code>x10</code>). Plugging
devices on a register like that is not super elegant, it would be better
to have a special address in memory that is not really actual RAM but
that has a register plugged to the LEDs. With this idea, one can add as
many devices as he likes, by assigning a virtual address to each device.
Then the SOC will have address decoding hardware that routes the data to
the right device. As you will see, besides removing from the processor
the wires drawn from <code>x10</code> to the LEDS, this only requires
some small modifications in the SOC.</p>
<p>Before starting to modify the SOC, the first thing to do is to decide
about the “memory map”, that is, which address space portion corresponds
to what. In our system, we have 6 kB of RAM, so in practice we could say
that addresses between 0 and 2^13-1 (8 kB, let us keep a power of two)
correspond to RAM. I decided to use a larger portion of address space
for RAM (because we also have FPGAs that have ampler quantities of
BRAM), then the address space dedicated to RAM will be between 0 and
2^22-1 (that is, 4 MB of RAM).</p>
<p>Then, I decided to say that if bit 22 is set in an address, then this
address corresponds to a device. Now we need to specify how to select
among multiple devices. A natural idea is to use bits 0 to 21 as a
“device index”, but doing so is going to require multiple 22-bits wide
comparators, and on our IceStick, it will eat-up a significant portion
of the removing LUTs. A better idea, suggested (once again) by Matthias
Koch (<span class="citation" data-cites="mecrisp">@mecrisp</span>), is
to use 1-hot encoding, that is, data is routed to device number
<code>n</code> if bit <code>n</code> is set in the address. We will only
consider “word addresses” (that is, ignore the two LSBs). Doing that, we
can only plug 20 different devices to our SOC, but it is still much more
than what we need. The advantage is that it dramatically simplifies
address decoding, in such a way that everything still fits in the
IceStick.</p>
<p>To determine whether a memory request should be routed to the RAM or
to the devices, we insert the following circuitry into the SOC:</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> RAM_rdata<span class="op">;</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">29</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> mem_wordaddr <span class="op">=</span> mem_addr<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isIO  <span class="op">=</span> mem_addr<span class="op">[</span><span class="dv">22</span><span class="op">];</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isRAM <span class="op">=</span> <span class="op">!</span>isIO<span class="op">;</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> mem_wstrb <span class="op">=</span> <span class="op">|</span>mem_wmask<span class="op">;</span></span></code></pre></div>
<p>The RAM is wired as follows:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>   Memory RAM<span class="op">(</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>      .clk<span class="op">(</span>clk<span class="op">),</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>      .mem_addr<span class="op">(</span>mem_addr<span class="op">),</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>      .mem_rdata<span class="op">(</span>RAM_rdata<span class="op">),</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>      .mem_rstrb<span class="op">(</span>isRAM <span class="op">&amp;</span> mem_rstrb<span class="op">),</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>      .mem_wdata<span class="op">(</span>mem_wdata<span class="op">),</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>      .mem_wmask<span class="op">({</span><span class="dv">4</span><span class="op">{</span>isRAM<span class="op">}}&amp;</span>mem_wmask<span class="op">)</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span></code></pre></div>
<p>(note the <code>isRAM</code> signal ANDed with the write mask)</p>
<p>Now we can add the logic to wire our LEDs. They are declared as a
<code>reg</code> in the SOC module interface:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> SOC <span class="op">(</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>        CLK<span class="op">,</span> </span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>        RESET<span class="op">,</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="dt">reg</span> <span class="op">[</span><span class="dv">4</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> LEDS<span class="op">,</span> </span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span>        RXD<span class="op">,</span> </span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span>       TXD  </span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<p>driven by a simple block:</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> IO_LEDS_bit <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  </span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>isIO <span class="op">&amp;</span> mem_wstrb <span class="op">&amp;</span> mem_wordaddr<span class="op">[</span>IO_LEDS_bit<span class="op">])</span> <span class="kw">begin</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>     LEDS <span class="op">&lt;=</span> mem_wdata<span class="op">;</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>Now we can write (yet another version of) our old good blinky:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>gp<span class="op">,</span><span class="bn">32&#39;h400000</span><span class="op">);</span> </span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>L1_<span class="op">);</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>      SW<span class="op">(</span>a0<span class="op">,</span>gp<span class="op">,</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>wait_<span class="op">));</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>a0<span class="op">,</span>a0<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>      J<span class="op">(</span>LabelRef<span class="op">(</span>L1_<span class="op">));</span></span></code></pre></div>
<p>First we load the base address of the IO page in <code>gp</code>
(that is, <code>2^22</code>). To write LEDs value, we store
<code>a0</code> to word address 1 (that is address 4) in the IO page. To
make things easier when we’ll have several devices (right after), let us
write some helper functions:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Memory-mapped IO in IO page, 1-hot addressing in word address.   </span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> IO_LEDS_bit      <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// W five leds</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Converts an IO_xxx_bit constant into an offset in IO page.</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">function</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> IO_BIT_TO_OFFSET<span class="op">;</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">input</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> bit<span class="op">;</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">begin</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>     IO_BIT_TO_OFFSET <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>bit <span class="op">+</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">endfunction</span></span></code></pre></div>
<p>Then we can write to the LEDs as follows:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>   SW<span class="op">(</span>a0<span class="op">,</span>gp<span class="op">,</span>IO_BIT_TO_OFFSET<span class="op">(</span>IO_LEDS_bit<span class="op">));</span></span></code></pre></div>
<p><em>OK, is it all what you have, still your stupid blinky after 17
(!) tutorial steps ?</em></p>
<p>Sure, you are right man. Let us add an UART to allow our core to
display stuff to a virtual terminal. The IceStick (and many other FPGA
boards) has a special chip (FTDI2232H if you want to know), that
translates between the plain old RS232 serial protocol and USB. It is
good news for us, because RS232 is a simple protocol, much easier to
implement than USB. In fact, our core will communicate with the outside
word through two pins (one for sending data, called <code>TXD</code> and
one for receiving data, called <code>RXD</code>), and the FTDI chip
converts to the USB protocol for you. Moreover, it is a good idea not
reinventing the wheel, and there are many existing implementation of
UART (Universal Asynchronous Receiver Transmitter, that implement the
RS232 protocol) in VERILOG. For our purpose, for now we will only
implement half of it (that is, the part that lets our processor send
data over it to display text in a terminal emulator).</p>
<p>Olof Kindren has written a <a
href="https://twitter.com/OlofKindgren/status/1409634477135982598">Tweet-size
UART</a>, more legible version <a
href="https://gist.github.com/olofk/e91fba2572396f55525f8814f05fb33d">here</a>.</p>
<p>Let us insert it into our SOC and connect it:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Memory-mapped IO in IO page, 1-hot addressing in word address.   </span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> IO_LEDS_bit      <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// W five leds</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> IO_UART_DAT_bit  <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// W data to send (8 bits) </span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> IO_UART_CNTL_bit <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>  <span class="co">// R status. bit 9: busy sending</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> uart_valid <span class="op">=</span> isIO <span class="op">&amp;</span> mem_wstrb <span class="op">&amp;</span> mem_wordaddr<span class="op">[</span>IO_UART_DAT_bit<span class="op">];</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> uart_ready<span class="op">;</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>   corescore_emitter_uart #<span class="op">(</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>      .clk_freq_hz<span class="op">(</span><span class="ot">`BOARD_FREQ</span>*<span class="dv">1000000</span><span class="op">),</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>      .baud_rate<span class="op">(</span><span class="dv">115200</span><span class="op">)</span>                </span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>   <span class="op">)</span> UART<span class="op">(</span></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>      .i_clk<span class="op">(</span>clk<span class="op">),</span></span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>      .i_rst<span class="op">(!</span>resetn<span class="op">),</span></span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>      .i_data<span class="op">(</span>mem_wdata<span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]),</span></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>      .i_valid<span class="op">(</span>uart_valid<span class="op">),</span></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>      .o_ready<span class="op">(</span>uart_ready<span class="op">),</span></span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>      .o_uart_tx<span class="op">(</span>TXD<span class="op">)</span>                      </span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> IO_rdata <span class="op">=</span> </span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>           mem_wordaddr<span class="op">[</span>IO_UART_CNTL_bit<span class="op">]</span> <span class="op">?</span> <span class="op">{</span> <span class="bn">22&#39;b0</span><span class="op">,</span> <span class="op">!</span>uart_ready<span class="op">,</span> <span class="bn">9&#39;b0</span><span class="op">}</span></span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a>                                          <span class="op">:</span> <span class="bn">32&#39;b0</span><span class="op">;</span></span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_rdata <span class="op">=</span> isRAM <span class="op">?</span> RAM_rdata <span class="op">:</span></span>
<span id="cb81-27"><a href="#cb81-27" aria-hidden="true" tabindex="-1"></a>                          IO_rdata <span class="op">;</span></span>
<span id="cb81-28"><a href="#cb81-28" aria-hidden="true" tabindex="-1"></a>   </span></code></pre></div>
<p>The UART is projected onto two different addresses in memory space.
The first one, that can be only written to, sends one character. The
second one, that can be only read from, indicates whether the UART is
ready (bit 9 = 0) or busy sending a character (bit 9 = 1).</p>
<p>Now our processor has more possibilities to communicate with the
outside world than the poor five LEDs we had before ! Let us implement a
function to send a character:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>putc_<span class="op">);</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Send character to UART</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>      SW<span class="op">(</span>a0<span class="op">,</span>gp<span class="op">,</span>IO_BIT_TO_OFFSET<span class="op">(</span>IO_UART_DAT_bit<span class="op">));</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Read UART status, and loop until bit 9 (busy sending)</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>      <span class="co">// is zero.</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>t0<span class="op">,</span><span class="dv">1</span><span class="op">&lt;&lt;</span><span class="dv">9</span><span class="op">);</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>putc_L0_<span class="op">);</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>      LW<span class="op">(</span>t1<span class="op">,</span>gp<span class="op">,</span>IO_BIT_TO_OFFSET<span class="op">(</span>IO_UART_CNTL_bit<span class="op">));</span>     </span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>      AND<span class="op">(</span>t1<span class="op">,</span>t1<span class="op">,</span>t0<span class="op">);</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>      BNEZ<span class="op">(</span>t1<span class="op">,</span>LabelRef<span class="op">(</span>putc_L0_<span class="op">));</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>      RET<span class="op">();</span></span></code></pre></div>
<p>It writes the character to the UART address projected in IO space,
then loops while the UART status indicates that it is busy sending a
character.</p>
<p><strong>Try this</strong> run <a href="step17.v">step17.v</a> in
simulation.</p>
<p><em>Wait a minute</em> in simulation, how does it know how to display
something ?</p>
<p>It’s because I cheated a bit, I added the following block of code to
the SOC:</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`ifdef BENCH</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(</span>uart_valid<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>     <span class="dt">$write</span><span class="op">(</span><span class="st">&quot;%c&quot;</span><span class="op">,</span> mem_wdata<span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">);</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>     <span class="dt">$fflush</span><span class="op">(</span><span class="bn">32&#39;h8000_0001</span><span class="op">);</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="ot">`endif   </span></span></code></pre></div>
<p>(the magic constant argument to<code>$fflush()</code> corresponds to
<code>stdout</code>, you need to do that else you do not see anything on
the terminal until the output buffer of <code>stdout</code> is full).
Doing so we do not test the UART in simulation (it is completely
bypassed). I trust Olof that it works fine, but to do things properly,
it would be better to plug something on the simulated <code>TXD</code>
signal, decode the RS232 protocol and display the characters (we’ll see
examples of this type of simulation later on).</p>
<p><strong>Try this</strong> run <a href="step17.v">step17.v</a> on
device.</p>
<p>To display what’s sent to the UART, use:</p>
<pre><code>  $ ./terminal.sh</code></pre>
<p><em>Note</em> edit <code>terminal.sh</code> and chose your favourite
terminal emulator in there. You may also need to change
<code>DEVICE=/dev/ttyUSB1</code> according to your local
configuration.</p>
<h2 id="step-18-computing-the-mandelbrot-set">Step 18: Computing the
Mandelbrot set</h2>
<p>Now that we have a functional RISC-V processor and a SOC with an UART
that can send characters to a virtual terminal, let us rest a little bit
with a purely software step. In this step, we are going to write a
program in RISC-V assembly that computes a crude, ASCII-art version of
the Mandelbrot set.</p>
<p>Our “image” will be made of 80x80 characters. So let us start by
writing a program that fills the image with “*” characters. To do that,
we will use two nested loops. The Y coordinate will be stored in
<code>s0</code> and the X coordinate in <code>s1</code>. The upper bound
(80) will be stored in <code>s11</code>. The program looks like
that:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>gp<span class="op">,</span><span class="bn">32&#39;h400000</span><span class="op">);</span> <span class="co">// IO page</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s1<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s11<span class="op">,</span><span class="dv">80</span><span class="op">);</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>loop_y_<span class="op">);</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s0<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>loop_x_<span class="op">);</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="st">&quot;*&quot;</span><span class="op">);</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>putc_<span class="op">));</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>s0<span class="op">,</span>s0<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>      BNE<span class="op">(</span>s0<span class="op">,</span>s11<span class="op">,</span>LabelRef<span class="op">(</span>loop_x_<span class="op">));</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="dv">13</span><span class="op">);</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>putc_<span class="op">));</span></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>putc_<span class="op">));</span>      </span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>s1<span class="op">,</span>s1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a>      BNE<span class="op">(</span>s1<span class="op">,</span>s11<span class="op">,</span>LabelRef<span class="op">(</span>loop_y_<span class="op">));</span></span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true" tabindex="-1"></a>      EBREAK<span class="op">();</span></span></code></pre></div>
<p>(and we copy the <code>putc</code> function from the previous
example).</p>
<p><strong>Fixed point</strong> So now we want to compute the Mandelbrot
set. To do that, we need to manipulate real numbers. Unfortunately, our
super simplistic RISC-V core is not able to directly manipulate floating
point numbers. The C compiler’s support library <code>libgcc</code> has
some functions to support them, but we will see later how to use them.
For now, the idea is to compute the Mandelbrot set using fixed-point
numbers, that is, in an integer number, we will use some bits to
represent the fractional part (10 bits in our case), and some bits to
represent the integer parts (22 bits in our case). In other words, it
means that if we want to represent a real number <code>x</code>, we will
store (the integer part of) <code>x*2^10</code> in a register. It is
similar to floating point numbers, except that the exponent in our case
is always 10. We will use the following constants in our program:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> mandel_shift <span class="dv">10</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> mandel_mul <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="ot">`mandel_shift</span><span class="op">)</span></span></code></pre></div>
<p>Now, to compute the sum or the difference of two numbers, it does not
change anything, because the <code>2^10</code> factor is the same for
both numbers to be added (or subtracted). For a product it is a
different story, because when you compute <code>x*y</code>, the actual
computation that you do is <code>x*2^10*y*2^10</code>, so what you get
is <code>(x*y)*2^20</code>, and you wanted <code>(x*y)*2^10</code>, so
you need to divide by <code>2^10</code> (right shift by
<code>10</code>). OK, that’s good, but how do we compute the product of
two integer numbers stored in two registers ? Our processor has no
<code>MUL</code> instruction ? In fact it is possible to add a
<code>MUL</code> instruction (it is part of the RV32M instruction set),
we will see that later, but it will not fit within our tiny IceStick !
So what can we do ? We can implement a function that takes two numbers
in <code>a0</code> and <code>a1</code>, computes their products and
returns it in <code>a0</code>. The C compiler support library
<code>libgcc</code> has one (it is what is used when compiling C for
small RV32I RISC-V processors that do not have the <code>MUL</code>
instruction, like ours). The source-code of this function is <a
href="https://github.com/riscv-collab/riscv-gcc/blob/5964b5cd72721186ea2195a7be8d40cfe6554023/libgcc/config/riscv/muldi3.S">here</a>.
Let us port it to our VERILOG RISC-V assembler (that has a slightly
different syntax unfortunately, we will see later how to directly use
gcc and gas):</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Mutiplication routine,</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Input in a0 and a1</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Result in a0</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>mulsi3_<span class="op">);</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a2<span class="op">,</span>a0<span class="op">);</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>mulsi3_L0_<span class="op">);</span> </span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>      ANDI<span class="op">(</span>a3<span class="op">,</span>a1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>      BEQZ<span class="op">(</span>a3<span class="op">,</span>LabelRef<span class="op">(</span>mulsi3_L1_<span class="op">));</span> </span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>a0<span class="op">,</span>a0<span class="op">,</span>a2<span class="op">);</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>mulsi3_L1_<span class="op">);</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>      SRLI<span class="op">(</span>a1<span class="op">,</span>a1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>      SLLI<span class="op">(</span>a2<span class="op">,</span>a2<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>      BNEZ<span class="op">(</span>a1<span class="op">,</span>LabelRef<span class="op">(</span>mulsi3_L0_<span class="op">));</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>      RET<span class="op">();</span></span></code></pre></div>
<p>(do not forget to declare the new labels before the
<code>initial</code> block).</p>
<p>So now, before displaying the Mandelbrot set, to test our fixed-point
computation idea, let us display a simpler shape, that is, we consider
we are visualizing the <code>[-2.0,2.0]x[-2.0,2.0]</code> square (mapped
to our 30x30 characters display), and we want to display a disk of
radius <code>2</code> centered on <code>(0,0)</code>. To do that, we
need first to compute the (fixed point) coordinates <code>x,y</code>.
They will be stored in <code>s2</code> and <code>s3</code>. Then we need
to compute <code>x^2+y^2</code>. We can do that by invoking the
<code>mulsi3</code> routine twice (do not forget to rightshift the
result by 10). Finally, we compare the result with
<code>4 &lt;&lt; 10</code> (4 because it is the <em>squared</em> radius,
and shifted to the left by 10 because of our fixed-point
representation), to decide whether the point was inside or outside the
disk, and use a different character to display it. The corresponding
program looks like that:</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> mandel_shift <span class="dv">10</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> mandel_mul <span class="op">(</span><span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="ot">`mandel_shift</span><span class="op">)</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> xmin <span class="op">(-</span><span class="dv">2</span>*<span class="ot">`mandel_mul</span><span class="op">)</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> xmax <span class="op">(</span> <span class="dv">2</span>*<span class="ot">`mandel_mul</span><span class="op">)</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> ymin <span class="op">(-</span><span class="dv">2</span>*<span class="ot">`mandel_mul</span><span class="op">)</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> ymax <span class="op">(</span> <span class="dv">2</span>*<span class="ot">`mandel_mul</span><span class="op">)</span>    </span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> dx <span class="op">((</span><span class="ot">`xmax</span><span class="op">-</span><span class="ot">`xmin</span><span class="op">)/</span><span class="dv">30</span><span class="op">)</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> dy <span class="op">((</span><span class="ot">`ymax</span><span class="op">-</span><span class="ot">`ymin</span><span class="op">)/</span><span class="dv">30</span><span class="op">)</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>   <span class="ot">`define</span> norm_max <span class="op">(</span><span class="dv">4</span> <span class="op">&lt;&lt;</span> <span class="ot">`mandel_shift</span><span class="op">)</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span>    loop_y_      <span class="op">=</span> <span class="dv">28</span><span class="op">;</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span>    loop_x_      <span class="op">=</span> <span class="dv">36</span><span class="op">;</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>   <span class="dt">integer</span>    in_disk_     <span class="op">=</span> <span class="dv">92</span><span class="op">;</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>gp<span class="op">,</span><span class="bn">32&#39;h400000</span><span class="op">);</span> <span class="co">// IO page</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s1<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s3<span class="op">,</span><span class="ot">`xmin</span><span class="op">);</span></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s11<span class="op">,</span><span class="dv">30</span><span class="op">);</span></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s10<span class="op">,</span><span class="ot">`norm_max</span><span class="op">);</span></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>loop_y_<span class="op">);</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s0<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s2<span class="op">,</span><span class="ot">`ymin</span><span class="op">);</span></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>loop_x_<span class="op">);</span></span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a0<span class="op">,</span>s2<span class="op">);</span></span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a1<span class="op">,</span>s2<span class="op">);</span></span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>mulsi3_<span class="op">));</span></span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a>      SRLI<span class="op">(</span>s4<span class="op">,</span>a0<span class="op">,</span><span class="ot">`mandel_shift</span><span class="op">);</span> <span class="co">// s4 = x*x</span></span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a0<span class="op">,</span>s3<span class="op">);</span></span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a1<span class="op">,</span>s3<span class="op">);</span></span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>mulsi3_<span class="op">));</span></span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a>      SRLI<span class="op">(</span>s5<span class="op">,</span>a0<span class="op">,</span><span class="ot">`mandel_shift</span><span class="op">);</span> <span class="co">// s5 = y*y</span></span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>s6<span class="op">,</span>s4<span class="op">,</span>s5<span class="op">);</span>             <span class="co">// s6 = x*x+y*y</span></span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="st">&quot;*&quot;</span><span class="op">);</span></span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a>      BLT<span class="op">(</span>s6<span class="op">,</span>s10<span class="op">,</span>LabelRef<span class="op">(</span>in_disk_<span class="op">));</span> <span class="co">// if x*x+y*y &lt; 4</span></span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb88-41"><a href="#cb88-41" aria-hidden="true" tabindex="-1"></a>  Label<span class="op">(</span>in_disk_<span class="op">);</span></span>
<span id="cb88-42"><a href="#cb88-42" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>putc_<span class="op">));</span> </span>
<span id="cb88-43"><a href="#cb88-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-44"><a href="#cb88-44" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>s0<span class="op">,</span>s0<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb88-45"><a href="#cb88-45" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>s2<span class="op">,</span>s2<span class="op">,</span><span class="ot">`dx</span><span class="op">);</span></span>
<span id="cb88-46"><a href="#cb88-46" aria-hidden="true" tabindex="-1"></a>      BNE<span class="op">(</span>s0<span class="op">,</span>s11<span class="op">,</span>LabelRef<span class="op">(</span>loop_x_<span class="op">));</span></span>
<span id="cb88-47"><a href="#cb88-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-48"><a href="#cb88-48" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="dv">13</span><span class="op">);</span></span>
<span id="cb88-49"><a href="#cb88-49" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>putc_<span class="op">));</span></span>
<span id="cb88-50"><a href="#cb88-50" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb88-51"><a href="#cb88-51" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>putc_<span class="op">));</span>      </span>
<span id="cb88-52"><a href="#cb88-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-53"><a href="#cb88-53" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>s1<span class="op">,</span>s1<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb88-54"><a href="#cb88-54" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>s3<span class="op">,</span>s3<span class="op">,</span><span class="ot">`dy</span><span class="op">);</span></span>
<span id="cb88-55"><a href="#cb88-55" aria-hidden="true" tabindex="-1"></a>      BNE<span class="op">(</span>s1<span class="op">,</span>s11<span class="op">,</span>LabelRef<span class="op">(</span>loop_y_<span class="op">));</span></span>
<span id="cb88-56"><a href="#cb88-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-57"><a href="#cb88-57" aria-hidden="true" tabindex="-1"></a>      EBREAK<span class="op">();</span> </span></code></pre></div>
<p>and the output looks like that:</p>
<pre><code>          ***********         
        ***************       
       ******************     
     *********************    
    ***********************   
    ************************  
   *************************  
  *************************** 
  *************************** 
 *****************************
 *****************************
 *****************************
 *****************************
 *****************************
 *****************************
 *****************************
 *****************************
 *****************************
 *****************************
 *****************************
  *************************** 
  *************************** 
   *************************  
   *************************  
    ***********************   
     *********************    
      *******************     
        ***************       
          ***********         </code></pre>
<p>Now to compute the Mandelbrot set, we need to iterate the following
operation:</p>
<pre><code>   Z &lt;- 0; iter &lt;- 0
   do
      Z &lt;- Z^2 + C
      iter &lt;- iter + 1
   while |Z| &lt; 2</code></pre>
<p>where <code>Z</code> and <code>C</code> are complex numbers.
<code>C = x + iy</code> corresponds to the current pixel. Remember the
rule for complex number multiplication (<code>i*i = -1</code>), we can
compute <code>Z^2 = (Zr + i*Zi)^2 = Zr^2-Zi^2 + 2*i*Zr*Zi</code>. The
loop that computes these iterates writes:</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>loop_Z_<span class="op">);</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a0<span class="op">,</span>s4<span class="op">);</span> <span class="co">// Zrr  &lt;- (Zr*Zr) &gt;&gt; mandel_shift</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a1<span class="op">,</span>s4<span class="op">);</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>mulsi3_<span class="op">));</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>      SRLI<span class="op">(</span>s6<span class="op">,</span>a0<span class="op">,</span><span class="ot">`mandel_shift</span><span class="op">);</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a0<span class="op">,</span>s4<span class="op">);</span> <span class="co">// Zri &lt;- (Zr*Zi) &gt;&gt; (mandel_shift-1)</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a1<span class="op">,</span>s5<span class="op">);</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>mulsi3_<span class="op">));</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>      SRAI<span class="op">(</span>s7<span class="op">,</span>a0<span class="op">,</span><span class="ot">`mandel_shift</span><span class="dv">-1</span><span class="op">);</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a0<span class="op">,</span>s5<span class="op">);</span> <span class="co">// Zii &lt;- (Zi*Zi) &gt;&gt; (mandel_shift)</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>      MV<span class="op">(</span>a1<span class="op">,</span>s5<span class="op">);</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>      CALL<span class="op">(</span>LabelRef<span class="op">(</span>mulsi3_<span class="op">));</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>      SRLI<span class="op">(</span>s8<span class="op">,</span>a0<span class="op">,</span><span class="ot">`mandel_shift</span><span class="op">);</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>      SUB<span class="op">(</span>s4<span class="op">,</span>s6<span class="op">,</span>s8<span class="op">);</span> <span class="co">// Zr &lt;- Zrr - Zii + Cr  </span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>s4<span class="op">,</span>s4<span class="op">,</span>s2<span class="op">);</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>s5<span class="op">,</span>s7<span class="op">,</span>s3<span class="op">);</span> <span class="co">// Zi &lt;- 2Zri + Cr</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>      ADD<span class="op">(</span>s6<span class="op">,</span>s6<span class="op">,</span>s8<span class="op">);</span> <span class="co">// if norm &gt; norm max, exit loop</span></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>s7<span class="op">,</span><span class="ot">`norm_max</span><span class="op">);</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>      BGT<span class="op">(</span>s6<span class="op">,</span>s7<span class="op">,</span>LabelRef<span class="op">(</span>exit_Z_<span class="op">));</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>      ADDI<span class="op">(</span>s10<span class="op">,</span>s10<span class="op">,-</span><span class="dv">1</span><span class="op">);</span>  <span class="co">// iter--, loop if non-zero</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>      BNEZ<span class="op">(</span>s10<span class="op">,</span>LabelRef<span class="op">(</span>loop_Z_<span class="op">));</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>   Label<span class="op">(</span>exit_Z_<span class="op">);</span></span></code></pre></div>
<p>in the end, we display different characters depending on the value of
<code>iter</code> (<code>s10</code>) when the loop is exited:</p>
<pre><code>   Label(exit_Z_);
      LI(a0,colormap_);
      ADD(a0,a0,s10);
      LBU(a0,a0,0);
      CALL(LabelRef(putc_));</code></pre>
<p>where the “colormap” is an array of characters that mimic different
“intensities”, from the darkest to the brightest:</p>
<pre><code>   Label(colormap_);
      DATAB(&quot; &quot;,&quot;.&quot;,&quot;,&quot;,&quot;:&quot;);
      DATAB(&quot;;&quot;,&quot;o&quot;,&quot;x&quot;,&quot;%&quot;);
      DATAB(&quot;#&quot;,&quot;@&quot;, 0 , 0 );            </code></pre>
<p><img
src="https://github.com/BrunoLevy/learn-fpga/blob/master/FemtoRV/TUTORIALS/Images/mandelbrot_terminal.gif" /></p>
<p><strong>Try that</strong> run <a href="step18.v">step18.v</a> in
simulation and on the device. Modify it to draw your own graphics (for
instance, try drawing “concentric circles” using the “colormap”).</p>
<h2 id="step-19-faster-simulation-with-verilator">Step 19: Faster
simulation with Verilator</h2>
<p>As you have seen in Step 18, simulation is much much slower than
running the design on the device. However, there is another tool, called
<code>verilator</code>, that lets you convert a VERILOG design into C++.
Then you compile the C++, and you have a simulation that is much much
faster than icarus/iverilog. Let us first install verilator:</p>
<pre><code>  $ apt-get install verilator</code></pre>
<p>Before transforming our design into C++, we will have to create a
“bench”, that is, some C++ code that will generate the signals for our
design, and that will declare the C++ <code>main()</code> function. The
main role of the main function is to declare an object of class
<code>VSOC</code> (generated from our <code>SOC</code> module), and
wiggle its <code>CLK</code> signal. Each time the <code>CLK</code>
signal is changed, you need to call the <code>eval()</code> function to
take the change into account. The <code>sim_main.cpp</code> file is as
follows:</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;VSOC.h&quot;</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;verilated.h&quot;</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> argv<span class="op">,</span> <span class="dt">char</span><span class="op">**</span> env<span class="op">)</span> <span class="op">{</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>   VSOC top<span class="op">;</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>   top<span class="op">.</span>CLK <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span><span class="op">(!</span>Verilated<span class="op">::</span>gotFinish<span class="op">())</span> <span class="op">{</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>      top<span class="op">.</span>CLK <span class="op">=</span> <span class="op">!</span>top<span class="op">.</span>CLK<span class="op">;</span></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>      top<span class="op">.</span>eval<span class="op">();</span></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In addition, in <a href="sim_main.cpp">sim_main.cpp</a>, there is
some code to decode whenever the LEDs change, and display their
status.</p>
<p>To convert a design to C++, use the following command:</p>
<pre><code>  $ verilator -DBENCH -DBOARD_FREQ=12 -Wno-fatal --top-module SOC -cc -exe sim_main.cpp step18.v</code></pre>
<p>Then to compile the C++ and run the generated program:</p>
<pre><code>  $ cd obj_dir
  $ make -f VSOC.mk
  $ ./VSOC</code></pre>
<p>As you can see, it is much much faster than icarus/iverilog ! For a
small design, it does not make a huge difference, but believe me, when
you are developping an RV32IMFC core, with a FPU, it is good to have
efficient simulation !</p>
<p>To make things easier, there is a <code>run_verilator.sh</code>
script, that you can invoke as follows:</p>
<pre><code>  $ run_verilator.sh step18.v</code></pre>
<h2
id="step-20-using-the-gnu-toolchain-to-compile-programs---assembly">Step
20: Using the GNU toolchain to compile programs - assembly</h2>
<p>At this step, you may have the feeling that our RISC-V design is just
a toy, for educational purpose, far away from “the real thing”. In fact,
at this step, you will start feeling that what you have done is as real
as any other RISC-V processor ! What makes a processor interesting is
the software you can run on it, hence if our thingy can run any software
written for a (RV32I) RISC-V processor, then it is a RV32I RISC-V
processor.</p>
<p><em>Wait a minute</em> but what we have used up to now to write the
software is the VERILOG assembler, it is just a toy, different from the
real thing no ?</p>
<p>In fact, the VERILOG assembler generates exactly the same machine
code as any other RISC-V assembler. We coud use instead any other RISC-V
assembler, load the generated machine code into our design and run it
!</p>
<p>To do so, VERILOG has a <code>$readmemh()</code> command, that loads
the data to initialize a memory from an external file. It is used as
follows in <a href="step20.v">step20.v</a>:</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>       <span class="dt">$readmemh</span><span class="op">(</span><span class="st">&quot;firmware.hex&quot;</span><span class="op">,</span>MEM<span class="op">);</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>where <code>firmware.hex</code> is an ASCII file with the initial
content of <code>MEM</code> in hexadecimal.</p>
<p>So if we want to use an external assembler, all we have to do is
figure out the following things: - how to compile RISC-V assembly code
using GNU tools - how to tell GNU tools about the device we have created
(RAM start address, RAM amount) - how to convert the output of GNU tools
into a file that <code>$readmemh()</code> can understand</p>
<p>OK, let us start with a simple blinker, in <a
href="FIRMWARE/blinker.S">blinker.S</a>:</p>
<pre><code># Simple blinker

.equ IO_BASE, 0x400000  
.equ IO_LEDS, 4

.section .text

.globl start

start:
        li   gp,IO_BASE
    li   sp,0x1800
.L0:
    li   t0, 5
    sw   t0, IO_LEDS(gp)
    call wait
    li   t0, 10
    sw   t0, IO_LEDS(gp)
    call wait
    j .L0

wait:
        li t0,1
    slli t0, t0, 17
.L1:       
        addi t0,t0,-1
    bnez t0, .L1
    ret</code></pre>
<p>As you can see, it is very similar to the code we wrote up to now in
the VERILOG assembler. In this program, we have three different things:
- <strong>main program</strong> - <strong>utilities</strong>, here the
<code>wait</code> function - <strong>setup</strong>, that is,
initializing <code>gp</code> and <code>sp</code></p>
<p>So we will split the file into three parts: - <a
href="FIRMWARE/blinker.S">FIRMWARE/blinker.S</a> with the
<code>main</code> function - <a
href="FIRMWARE/wait.S">FIRMWARE/wait.S</a> with the <code>wait</code>
function - <a href="FIRMWARE/start.S">FIRMWARE/start.S</a> with the
setup code, that calls <code>main</code> in the end.</p>
<p>To compile it, you will need to install the RISC-V toolchain
(compiler, assembler, linker) on your machine. Our makefile can do that
for you:</p>
<pre><code>  $ cd learn-fpga/FemtoRV
  $ make ICESTICK.firmware_config</code></pre>
<p><em>Note:</em> always use <code>ICESTICK.firmware_config</code>, even
if you have a larger board, it will configure the makefiles for
<code>RV32I</code> build (and that’s what our processor supports).</p>
<p>This will download some files and unpack them in
<code>learn-fpga/FemtoRV/FIRMWARE/TOOLCHAIN</code>. Add the
<code>riscv64-unknown-elf-gcc..../bin/</code> directory to your
path.</p>
<p>Now to compile our program:</p>
<pre><code>  $ cd learn-fpga/FemtoRV/TUTORIALS/FROM_BLINKER_TO_RISCV/FIRMWARE
  $ riscv64-unknown-elf-as -march=rv32i -mabi=ilp32 -mno-relax start.S -o start.o  
  $ riscv64-unknown-elf-as -march=rv32i -mabi=ilp32 -mno-relax blinker.S -o blinker.o
  $ riscv64-unknown-elf-as -march=rv32i -mabi=ilp32 -mno-relax wait.S -o wait.o  </code></pre>
<p>We specify the architecture (<code>rv32i</code>) that corresponds to
the instructions supported by our processor and the ABI
(<code>ilp32</code>) that corresponds to the way functions are called.
THe <code>no-relax</code> option concerns the <code>gp</code> register
that we use for accessing the IO page (so we do not let the assembler
use it for anything else).</p>
<p>This generates object files (<code>.o</code>). We now need to
generate an executable from them, by invoking the linker. The linker
will determine where our code and data should be implanted in memory.
For that, we need to specify how the memory in our device is organized,
in a linker script (<a
href="FIRMWARE/bram.ld">FIRMWARE/bram.ld</a>):</p>
<pre><code>MEMORY
{
   BRAM (RWX) : ORIGIN = 0x0000, LENGTH = 0x1800  /* 6kB RAM */
}
SECTIONS
{
    everything :
    {
    . = ALIGN(4);
    start.o (.text)
        *(.*)
    } &gt;BRAM
}</code></pre>
<p>A linker script contains a description of <code>MEMORY</code>. In our
case, there is a single segment of 6 kB of memory, that we call
<code>BRAM</code>. It starts from address <code>0x0000</code>. Then we
have <code>SECTIONS</code>, that indicates what goes where (or which
segment goes to which memory). In our case, it is super simple:
everything goes to BRAM. We also indicate that the content of
<code>start.o</code> should be installed first in memory. The linker is
invoked as follows:</p>
<pre><code>  $ riscv64-unknown-elf-ld blinker.o wait.o -o blinker.bram.elf -T bram.ld -m elf32lriscv -nostdlib -norelax</code></pre>
<p>It generates an “elf” executable (“elf” stands for Executable and
Linkable Format). It is the same format as the binaries in a Linux
system. The option <code>-T bram.ld</code> tells it to use our linker
script. The option <code>-m elf32lriscv</code> indicates that we are
generating a 32-bits executable. We are not using the C stdlib for now
(<code>-nostdlib</code>) and we keep <code>gp</code> for ourselves
(<code>-norelax</code>). We do not need to have <code>start.o</code> on
the command line in the list of objects to link, because it is already
included in the linker script <code>bram.ld</code>.</p>
<p>We are not completely done, now we need to extract the relevant
information from the elf executable, and generate a file with all the
machine code in hexadecimal, so that VERILOG’s <code>$readmemh()</code>
function can understand it. For that, I wrote a
<code>firmware_words</code> utility, that understands the elf file
formats, extracts the parts that are interesting for us and writes them
in ASCII hexadecimal:</p>
<pre><code>  $ make blinker.bram.hex</code></pre>
<p><em>Note</em> you can invoke <code>make xxxx.bram.hex</code>
directly, it will invoke the assembler, linker and elf conversion
utility for you automatically.</p>
<p>Now you can run the example in simulation and on the device:</p>
<pre><code>  $ cd ..
  $ ./run_verilator.sh step20.v
  $ BOARDS/run_xxx.sh step20.v</code></pre>
<p>Now that things are easier, we can write more complicated programs.
Let us see how to write the famous “hello world” program. What we need
is a <code>putstring</code> routine to display a string on the tty. It
takes as input the address of the first character of the string to
display in <code>a0</code>. We just need to loop on all characters of
the string, and exit the loop as soon as we find a null character, and
call <code>putchar</code> for each character:</p>
<pre><code># Warning, buggy code ahead !
putstring:
    mv t2,a0    
.L2:    lbu a0,0(t2)
    beqz a0,.L3
    call putchar
    addi t2,t2,1    
    j .L2
.L3:    ret</code></pre>
<p>Have you seen the comment ? It means the code above has an error, can
you spot it ?</p>
<p>A hint, <code>putstring</code> is a function that calls a function.
Don’t we need to do special in this case ?</p>
<p>Do you remember what <code>call</code> and <code>ret</code> do ? Yes,
<code>call</code> stores <code>PC+4</code> in <code>ra</code> then jumps
to the function, and <code>ret</code> jumps to the address in
<code>ra</code>. Now suppose that somebody called our
<code>putstring</code> function. When we enter the function,
<code>ra</code> contains the address we are supposed to jump to when
reaching the <code>ret</code> statement in <code>putstring</code>. But
inside <code>putstring</code>, we call <code>putchar</code>, and it
overwrites <code>ra</code> with the address right after the call, so
that <code>putchar</code> will be able to jump there when it will
return, but <code>putstring</code> will jump there as well, which is not
what we want. To avoid that, we need to save <code>ra</code> at the
beginning of <code>putstring</code>, and restore it at the end. To do
that, we use the stack as follows:</p>
<pre><code>putstring:
    addi sp,sp,-4 # save ra on the stack
    sw ra,0(sp)   # (need to do that for functions that call functions)
    mv t2,a0    
.L2:    lbu a0,0(t2)
    beqz a0,.L3
    call putchar
    addi t2,t2,1    
    j .L2
.L3:    lw ra,0(sp)  # restore ra
    addi sp,sp,4 # resptore sp
    ret</code></pre>
<p>The function can be used as follows:</p>
<pre><code>   la   a0, hello
   call putstring
   
   ...

hello:
    .asciz &quot;Hello, world !\n&quot;</code></pre>
<p>The <code>la</code> (load address) pseudo-instruction loads the
address of the string in <code>a0</code>. The string is declared with a
standard label, and the <code>.asciz</code> directive that generates a
zero-terminated string.</p>
<p><strong>Try this</strong> Compile <code>hello.S</code>
(<code>cd FIRMWARE; make hello.bram.hex</code>) and test it in
simulation and on device. Try also <code>mandelbrot.S</code>. As you can
see, <a href="FIRMWARE/mandelbrot.S">FIRMWARE/mandelbrot.S</a> does not
have the <code>__mulsi</code> function. If you take a look at <a
href="FIRMWARE/Makefile">FIRMWARE/Makefile</a>, the executable is linked
with the right version of <code>libgcc.a</code> (for RV32I), that has
it.</p>
<p>Now you can start having a feeling that your processor is a real
thing: when you run the Mandelbrot example, it executes code on
<em>your</em> processor that was written by <em>somebody else</em>. Can
we go further and run code generated by standard tools ?</p>
<h2 id="step-21-using-the-gnu-toolchain-to-compile-programs---c">Step
21: Using the GNU toolchain to compile programs - C</h2>
<p>Let us see now how we can write code in C for our processor. At this
point, we are able to generate object files (<code>.o</code>) and
produce an elf executable from them using the linker. Our linker script
ensures that everything goes at the right place in memory, then our
processor can execute the code, first the content of
<code>start.S</code>, implanted at address 0, that calls in turn the
<code>main</code> function. Up to now our programs were completely
written in assembly. The nice thing with the ABI (Application Binary
Interface), that we have seen at steps 13 and 14, is that it makes it
possible to combine object files (<code>.o</code>) produced by different
tools, as soon as they respect the ABI, which is the case (of course) of
the C compiler.</p>
<p>The example <a href="FIRMWARE/sieve.c">FIRMWARE/sieve.c</a>, taken
from the examples in picorv is a good candidate. It is interesting, it
does multiplications, divisions and modulos using integer numbers. These
operations are not implemented by our RV32I core, but they are supported
by the compiler using functions in <code>libgcc.a</code>, and since we
link with <code>libgcc.a</code>, this will work. However, the program
also uses <code>printf()</code> to display the result, and this function
is declared in <code>libc.a</code>. In principle, it would be possible
to use it, but <code>printf()</code> supports so many formats that its
code is too large and will not fit in our 6 kB or RAM. For this reason,
we include a much smaller / much simpler version in <a
href="FIRMWARE/print.c">FIRMWARE/print.c</a> (also taken from picorv),
and included in the objects to be linked with executables.</p>
<p><img src="mandel_and_riscvlogo.png" /></p>
<p>There are two other examples, a C version of the Mandelbrot program:
<a href="FIRMWARE/mandel_C.c">FIRMWARE/mandel_C.c</a>. It uses <a
href="https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences">ANSI
colors</a> to display low-resolution “graphics” in the terminal. There
is also <a href="FIRMWARE/riscv_logo.c">FIRMWARE/riscv_logo.c</a> that
displays a spinning Risc-V logo (in a 90-ish demoscene style !).</p>
<p><strong>Try this</strong> Compile <code>sieve.c</code>
(<code>cd FIRMWARE; make sieve.bram.hex</code>) and test it in
simulation (<code>./run_verilator.sh step20.v</code>) and on device
(<code>BOARDS/run_xxx.sh step20.v; ./terminal.sh</code>). Try the other
programs. Write your own programs (if you do not have an idea, try for
instance cellular automata, Life …). Note: the Verilator framework can
directly load ELF executables in simulation (no need to regenerate
<code>firmware.hex</code>). You can generate all demo programs:
<code>cd FIRMWARE; make hello.bram.elf mandelbrot.bram.elf mandel_C.bram.elf riscv_logo.bram.elf;cd ..</code>,
then run the one that you want using
<code>./run_verilator.sh step20.v FIRMWARE/mandel_C.bram.elf</code> or
<code>./obj_dir/FIRMWARE/mandel_C.bram.elf</code>.</p>
<p>Now you can see that your processor is not just a toy, it is a real
RISC-V processor on which you can run programs produced by standard
tools !</p>
<h2 id="step-22-storing-data-can-i-have-more-than-6-kb-of-memory">Step
22: Storing data: can I have more than 6 kB of memory ?</h2>
<p><em>and some optimizations in the processor</em></p>
<p><img src="IceStick_SPIFLASH.jpg" /></p>
<p>On the IceStick, there are only 8 blocks of 1 kB of BRAM, and since
we need to use two of them for the registers, this leaves only 6 kB of
RAM for our programs. It is sufficient for small programs like
Mandelbrot or little graphic demos, but you will very soon reach the
limit. The IceStick has a little chip (see figure) with 4 MBs of FLASH
memory (other boards have a similar chip). When you synthesize a design,
it is stored in this FLASH memory. On startup, the FPGA loads its
configuration from this chip. The nice thing is that the FPGA
configuration takes no more than a few kilobytes, this leaves us a lot
of space to store our own data. But we will need to create some
additional hardware to communicate with this chip.</p>
<p>As you can see on the figure, this chip only has 8 legs, how can we
address 4 MBs of data using 8 pins only ? In fact, this chip uses a
<em>serial protocol</em> (SPI). To access data, one sends the address to
be read on a pin, one bit at a time, then the chip sends the data back
on another pin, one bit at a time. If you want to learn more about it,
my notes about SPI flash are <a
href="https://github.com/BrunoLevy/learn-fpga/blob/master/FemtoRV/TUTORIALS/spi_flash.md">here</a>
and the VERILOG implementation is in <a
href="spi_flash.v">spi_flash.v</a>. It supports different protocols,
depending on the used number of pins and whether pins are
bidirectional.</p>
<p>The <code>MappedSPIFlash</code> module has the following
interface:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MappedSPIFlash<span class="op">(</span> </span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span> <span class="dt">wire</span>         clk<span class="op">,</span>          </span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span> <span class="dt">wire</span>         rstrb<span class="op">,</span>        </span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span> <span class="dt">wire</span> <span class="op">[</span><span class="dv">19</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>  word_address<span class="op">,</span> </span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="dt">wire</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> rdata<span class="op">,</span>        </span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="dt">wire</span>        rbusy<span class="op">,</span>        </span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="dt">wire</span>        CLK<span class="op">,</span>  </span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span> <span class="dt">reg</span>         CS_N<span class="op">,</span> </span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">inout</span>  <span class="dt">wire</span> <span class="op">[</span><span class="dv">1</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>  IO </span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th>signal</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>clk</td>
<td>system clock</td>
</tr>
<tr class="even">
<td>rstrb</td>
<td>read strobe, goes high whenever processor wants to read a word</td>
</tr>
<tr class="odd">
<td>word_address</td>
<td>address of the word to be read</td>
</tr>
<tr class="even">
<td>rdata</td>
<td>data read from memory</td>
</tr>
<tr class="odd">
<td>rbusy</td>
<td>asserted if busy receiving data</td>
</tr>
<tr class="even">
<td>CLK</td>
<td>clock pin of the SPI flash chip</td>
</tr>
<tr class="odd">
<td>CS_N</td>
<td>chip select pin of the SPI flash chip, active low</td>
</tr>
<tr class="even">
<td>IO</td>
<td>two bidirectional pins for sending and receiving data</td>
</tr>
</tbody>
</table>
<p>Now the idea is to modify our SOC in such a way that some addresses
correspond to the SPI flash. First we need to decide how it will be
projected into the memory space of our processor. The idea is to use bit
23 of memory addresses to select the SPI Flash. Then we have the
different signals to discriminate the different zones of our memory:</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isSPIFlash  <span class="op">=</span> mem_addr<span class="op">[</span><span class="dv">23</span><span class="op">];</span>      </span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isIO        <span class="op">=</span> mem_addr<span class="op">[</span><span class="dv">23</span><span class="op">:</span><span class="dv">22</span><span class="op">]</span> <span class="op">==</span> <span class="bn">2&#39;b01</span><span class="op">;</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isRAM       <span class="op">=</span> mem_addr<span class="op">[</span><span class="dv">23</span><span class="op">:</span><span class="dv">22</span><span class="op">]</span> <span class="op">==</span> <span class="bn">2&#39;b00</span><span class="op">;</span></span></code></pre></div>
<p>The <code>MappedSPIFlash</code> module is wired as follows:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> SPIFlash_rdata<span class="op">;</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> SPIFlash_rbusy<span class="op">;</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>   MappedSPIFlash SPIFlash<span class="op">(</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>      .clk<span class="op">(</span>clk<span class="op">),</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>      .word_address<span class="op">(</span>mem_wordaddr<span class="op">),</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>      .rdata<span class="op">(</span>SPIFlash_rdata<span class="op">),</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>      .rstrb<span class="op">(</span>isSPIFlash <span class="op">&amp;</span> mem_rstrb<span class="op">),</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>      .rbusy<span class="op">(</span>SPIFlash_rbusy<span class="op">),</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>      .CLK<span class="op">(</span>SPIFLASH_CLK<span class="op">),</span></span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>      .CS_N<span class="op">(</span>SPIFLASH_CS_N<span class="op">),</span></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a>      .IO<span class="op">(</span>SPIFLASH_IO<span class="op">)</span></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span></code></pre></div>
<p>(the pins <code>SPIFLASH_CLK</code>, <code>SPIFLASH_CS_N</code>,
<code>SPIFLASH_IO[0]</code> and <code>SPIFLASH_IO[1]</code> are declared
in the constraint file, in the <code>BOARDS</code> subdirectory).</p>
<p>The data sent to the processor has a three-ways mux:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_rdata <span class="op">=</span> isRAM      <span class="op">?</span> RAM_rdata <span class="op">:</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>                      isSPIFlash <span class="op">?</span> SPIFlash_rdata <span class="op">:</span> </span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>                               IO_rdata <span class="op">;</span></span></code></pre></div>
<p>OK, now our processor can automatically trigger a SPI flash read by
accessing memory with bit 23 set in the address, but how does it know
that data is ready ? (remember, data arrives one bit at a time). There
is this <code>SPIFlash_rbusy</code> that goes high whenever
<code>MappedSPIFlash</code> is busy receiving some data, we need to take
it into account in our processor’s state machine. We add a new input
signal <code>mem_rbusy</code> to our processor, and modify the state
machine as follows:</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>   <span class="dv">WAIT_DATA:</span> <span class="kw">begin</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(!</span>mem_rbusy<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>     state <span class="op">&lt;=</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>   ...</span></code></pre></div>
<p>Then, in the SOC, this signal is wired to
<code>SPIFlash_rbusy</code>:</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> mem_rbusy<span class="op">;</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>   Processor CPU<span class="op">(</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>     ...</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>     .mem_rbusy<span class="op">(</span>mem_rbusy<span class="op">),</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>     ...</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>   <span class="op">);</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_rbusy <span class="op">=</span> SPIFlash_rbusy<span class="op">;</span></span></code></pre></div>
<p>By the way, since we are revisiting the state machine, there is
something we can do. Remember this portion of the state machine, don’t
you think we could go faster ?</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>   <span class="dv">WAIT_INSTR:</span> <span class="kw">begin</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>      instr <span class="op">&lt;=</span> mem_rdata<span class="op">;</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>      state <span class="op">&lt;=</span> FETCH_REGS<span class="op">;</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>   <span class="dv">FETCH_REGS:</span> <span class="kw">begin</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>      rs1 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>rs1Id<span class="op">];</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>      rs2 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>rs2Id<span class="op">];</span></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>      state <span class="op">&lt;=</span> EXECUTE<span class="op">;</span></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>Yes, <code>rs1Id</code> and <code>rs2Id</code> are simply 5 wires
(each) drawn from <code>instr</code>, so we can get them from
<code>mem_rdata</code> directly, and fetch the registers in the
<code>WAIT_INSTR</code> state, as follows:</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>   <span class="dv">WAIT_INSTR:</span> <span class="kw">begin</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>      instr <span class="op">&lt;=</span> mem_rdata<span class="op">;</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>      rs1 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>mem_rdata<span class="op">[</span><span class="dv">19</span><span class="op">:</span><span class="dv">15</span><span class="op">]];</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>      rs2 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>mem_rdata<span class="op">[</span><span class="dv">24</span><span class="op">:</span><span class="dv">20</span><span class="op">]];</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>      state <span class="op">&lt;=</span> EXECUTE<span class="op">;</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>Doing so we gain one cycle per instruction, and it is an easy win
!</p>
<p>Oh, and one more thing, why do we need a <code>LOAD</code> and a
<code>STORE</code> state, could’nt we initiate memory transfers in the
<code>EXECUTE</code> state ? Yes we can, so we need to change the write
mask and read strobes accordingly, like that:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_rstrb <span class="op">=</span> <span class="op">(</span>state <span class="op">==</span> FETCH_INSTR <span class="op">||</span> <span class="op">(</span>state <span class="op">==</span> EXECUTE <span class="op">&amp;</span> isLoad<span class="op">));</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> mem_wmask <span class="op">=</span> <span class="op">{</span><span class="dv">4</span><span class="op">{(</span>state <span class="op">==</span> EXECUTE<span class="op">)</span> <span class="op">&amp;</span> isStore<span class="op">}}</span> <span class="op">&amp;</span> STORE_wmask<span class="op">;</span></span></code></pre></div>
<p>Then the state machine has 4 states only !</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> FETCH_INSTR <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> WAIT_INSTR  <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> EXECUTE     <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> WAIT_DATA   <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">1</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> state <span class="op">=</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(!</span>resetn<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>     PC    <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>     state <span class="op">&lt;=</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span> <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>     <span class="kw">if</span><span class="op">(</span>writeBackEn <span class="op">&amp;&amp;</span> rdId <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>        RegisterBank<span class="op">[</span>rdId<span class="op">]</span> <span class="op">&lt;=</span> writeBackData<span class="op">;</span></span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>     <span class="kw">end</span></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>     <span class="kw">case</span><span class="op">(</span>state<span class="op">)</span></span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>       <span class="dv">FETCH_INSTR:</span> <span class="kw">begin</span></span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> WAIT_INSTR<span class="op">;</span></span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a>       <span class="dv">WAIT_INSTR:</span> <span class="kw">begin</span></span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a>          instr <span class="op">&lt;=</span> mem_rdata<span class="op">;</span></span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a>          rs1 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>mem_rdata<span class="op">[</span><span class="dv">19</span><span class="op">:</span><span class="dv">15</span><span class="op">]];</span></span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>          rs2 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>mem_rdata<span class="op">[</span><span class="dv">24</span><span class="op">:</span><span class="dv">20</span><span class="op">]];</span></span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> EXECUTE<span class="op">;</span></span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a>       <span class="dv">EXECUTE:</span> <span class="kw">begin</span></span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span><span class="op">(!</span>isSYSTEM<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb119-26"><a href="#cb119-26" aria-hidden="true" tabindex="-1"></a>         PC <span class="op">&lt;=</span> nextPC<span class="op">;</span></span>
<span id="cb119-27"><a href="#cb119-27" aria-hidden="true" tabindex="-1"></a>          <span class="kw">end</span></span>
<span id="cb119-28"><a href="#cb119-28" aria-hidden="true" tabindex="-1"></a>          state <span class="op">&lt;=</span> isLoad  <span class="op">?</span> WAIT_DATA <span class="op">:</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb119-29"><a href="#cb119-29" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb119-30"><a href="#cb119-30" aria-hidden="true" tabindex="-1"></a>       <span class="dv">WAIT_DATA:</span> <span class="kw">begin</span></span>
<span id="cb119-31"><a href="#cb119-31" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span><span class="op">(!</span>mem_rbusy<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb119-32"><a href="#cb119-32" aria-hidden="true" tabindex="-1"></a>         state <span class="op">&lt;=</span> FETCH_INSTR<span class="op">;</span></span>
<span id="cb119-33"><a href="#cb119-33" aria-hidden="true" tabindex="-1"></a>          <span class="kw">end</span></span>
<span id="cb119-34"><a href="#cb119-34" aria-hidden="true" tabindex="-1"></a>       <span class="kw">end</span></span>
<span id="cb119-35"><a href="#cb119-35" aria-hidden="true" tabindex="-1"></a>     <span class="kw">endcase</span> </span>
<span id="cb119-36"><a href="#cb119-36" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb119-37"><a href="#cb119-37" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>There are several other things that we can optimize. First thing, you
may have noticed that the two LSBs of the instructions are always
<code>2'b11</code> in RV32I, so we do not need to load them:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">2</span><span class="op">]</span> instr<span class="op">;</span>  </span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>   instr <span class="op">&lt;=</span> mem_rdata<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>   ...</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> isALUreg  <span class="op">=</span>  <span class="op">(</span>instr<span class="op">[</span><span class="dv">6</span><span class="op">:</span><span class="dv">2</span><span class="op">]</span> <span class="op">==</span> <span class="bn">5&#39;b01100</span><span class="op">);</span> </span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>   ...</span></code></pre></div>
<p>Something else: we are doing all address computations with 32 bits,
whereas our address space has 24 bits only, we can save significant
resources there:</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">localparam</span> ADDR_WIDTH<span class="op">=</span><span class="dv">24</span><span class="op">;</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span>ADDR_WIDTH<span class="dv">-1</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> PCplusImm <span class="op">=</span> PC <span class="op">+</span> <span class="op">(</span> instr<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">?</span> Jimm<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>                  instr<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">?</span> Uimm<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>                             Bimm<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> <span class="op">);</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span>ADDR_WIDTH<span class="dv">-1</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> PCplus4 <span class="op">=</span> PC<span class="op">+</span><span class="dv">4</span><span class="op">;</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span>ADDR_WIDTH<span class="dv">-1</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> nextPC <span class="op">=</span> <span class="op">((</span>isBranch <span class="op">&amp;&amp;</span> takeBranch<span class="op">)</span> <span class="op">||</span> isJAL<span class="op">)</span> <span class="op">?</span> PCplusImm   <span class="op">:</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>                                      isJALR   <span class="op">?</span> <span class="op">{</span>aluPlus<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">1</span><span class="op">],</span><span class="bn">1&#39;b0</span><span class="op">}</span> <span class="op">:</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>                                                 PCplus4<span class="op">;</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a>   <span class="dt">wire</span> <span class="op">[</span>ADDR_WIDTH<span class="dv">-1</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span> loadstore_addr <span class="op">=</span> rs1 <span class="op">+</span> <span class="op">(</span>isStore <span class="op">?</span> Simm <span class="op">:</span> Iimm<span class="op">);</span></span></code></pre></div>
<p><img src="ST_NICCC_tty.png" /></p>
<p>OK, so now we are ready to test the new storage that we have. Up to
date verilog file is avalaible in <a href="step22.v">step22.v</a>. What
we will do is displaying an animation on the terminal. The animation is
a demo from the 90’s, that streams polygon data to a software polygon
renderer. Polygon data is a 640 kB binary file, available from
<code>learn_fpga/FemtoRV/FIRMWARE/EXAMPLES/DATA/scene1.dat</code> (see
other files in the same directory for more information about the file
format). First thing to do is writing the file to the SPI flash, from a
1MBytes offset. For ICE40-based boards (IceStick, IceBreaker), use:</p>
<pre><code> $ iceprog -o 1M learn_fpga/FemtoRV/FIRMWARE/EXAMPLES/DATA/scene1.dat</code></pre>
<p>For ECP5 boards (ULX3S), use:</p>
<pre><code> $ cp learn_fpga/FemtoRV/FIRMWARE/EXAMPLES/DATA/scene1.dat scene1.img
 $ ujprog -j flash -f 1048576 scene1.img</code></pre>
<p>(using latest version of <code>ujprog</code> compiled from <a
href="https://github.com/kost/fujprog">https://github.com/kost/fujprog</a>).</p>
<p>Now you can compile the program:</p>
<pre><code> $ cd FIRMWARE
 $ make ST_NICCC.bram.hex
 $ cd ..</code></pre>
<p>and send the design and the program to the device:</p>
<pre><code> $ BOARDS/run_xxx.sh step22.v
 $ ./terminal.sh</code></pre>
<p><strong>Try this</strong> Store an image in SPI Flash (in a format
that is easy to read), and write a program to display it. You can use
<code>printf("\033[48;2;%d;%d;%dm ",R,G,B);</code> to send a pixel
(where <code>R</code>,<code>G</code>,<code>B</code> are numbers between
0 and 255), and <code>printf("\033[48;2;0;0;0m\n");</code> after each
scanline.</p>
<h2 id="step-23-running-programs-from-spi-flash-first-steps">Step 23:
running programs from SPI Flash, first steps</h2>
<p>With what we have done in the previous step, we are now able to load
data from the SPI flash, and we have ample space for all our data, but
we still have only 6 kB that is shared between our code and variables,
it is not much ! It would be great to be able to use the SPI flash to
store our code, and execute it directly from there. We were able to
write nice demos that fit in 6 kB, imagine what you could do with 2 MB
for code, and the entire 6 kB available for your variables !</p>
<p>To be able to load code from the SPI flash, the only thing we need to
change is staying in the <code>WAIT_INSTR</code> state until
<code>mem_rbusy</code> is zero, hence we just need to test
<code>mem_rbusy</code> before changing <code>state</code> to
<code>EXECUTE</code>:</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>   <span class="dv">WAIT_INSTR:</span> <span class="kw">begin</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>      instr <span class="op">&lt;=</span> mem_rdata<span class="op">[</span><span class="dv">31</span><span class="op">:</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>      rs1 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>mem_rdata<span class="op">[</span><span class="dv">19</span><span class="op">:</span><span class="dv">15</span><span class="op">]];</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>      rs2 <span class="op">&lt;=</span> RegisterBank<span class="op">[</span>mem_rdata<span class="op">[</span><span class="dv">24</span><span class="op">:</span><span class="dv">20</span><span class="op">]];</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span><span class="op">(!</span>mem_rbusy<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>     state <span class="op">&lt;=</span> EXECUTE<span class="op">;</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>and we initialize the BRAM with the following program, that jumps to
address <code>0x00820000</code>:</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">initial</span> <span class="kw">begin</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>      LI<span class="op">(</span>a0<span class="op">,</span><span class="bn">32&#39;h00820000</span><span class="op">);</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>      JR<span class="op">(</span>a0<span class="op">);</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>This address corresponds to the address where the SPI flash is
projected into the address space of our CPU (<code>0x00800000</code> = 1
&lt;&lt; 23) plus an offset of 128kB (<code>0x20000</code>). This offset
of 128 kB is necessary because remember, we share the SPI Flash with the
FPGA that stores its configuration in it !</p>
<p>OK, that’s mostly it for the hardware part. Let us see now if we can
execute code from there. To do that, we will need a new linker script
(<a href="FIRMWARE/spiflash0.ld">FIRMWARE/spiflash0.ld</a>):</p>
<pre><code>MEMORY {
   FLASH (RX)  : ORIGIN = 0x00820000, LENGTH = 0x100000 /* 4 MB in flash */
}
SECTIONS {
    everything : {
    . = ALIGN(4);
    start.o (.text)
        *(.*)
    } &gt;FLASH
}</code></pre>
<p>It is the same thing as before, but we tell the linker to put
everything in flash memory (for now, we will see later how it works for
global variables). Let us test it with a program that does not write to
global variables, for instance <a
href="FIRMWARE/hello.S">FIRMWARE/hello.S</a>. To link it using our new
linker script, we do:</p>
<pre><code>  $ riscv64-unknown-elf-ld -T spiflash0.ld -m elf32lriscv -nostdlib -norelax hello.o putchar.o -o hello.spiflash0.elf</code></pre>
<p>But since it is tedious to type, it is automated by the Makefile:</p>
<pre><code>  $ make hello.spiflash0.elf</code></pre>
<p>Now you need to convert the ELF executable into a flat binary:</p>
<pre><code>  $ riscv64-unknown-elf-objcopy hello.spiflash0.elf hello.spiflash0.bin -O binary</code></pre>
<p>or with our Makefile:</p>
<pre><code>  $ make hello.spiflash0.bin</code></pre>
<p>and send it to the SPI flash at offset 128k:</p>
<pre><code>  $ iceprog -o 128k hello.spiflash0.bin</code></pre>
<p>or with our Makefile:</p>
<pre><code>  $ make hello.spiflash0.prog</code></pre>
<p>and then:</p>
<pre><code>  $ ./terminal.sh</code></pre>
<h2
id="step-24-running-programs-from-spi-flash-a-better-linker-script">Step
24: running programs from SPI Flash, a better linker script</h2>
<p>Before starting, let us make a little change in our core: when
pushing the reset button, it jumps at address 0, which is initialized as
a jump to flash memory, but after executing our program, it is possible
(and highly probable) that the RAM will have been used for something
else, and no longer has the jump-to-flash instruction. To fix this, one
can make the CPU jump to flash memory each time reset goes low:</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">if</span><span class="op">(!</span>resetn<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>     PC    <span class="op">&lt;=</span> <span class="bn">32&#39;h00820000</span><span class="op">;</span> </span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>     state <span class="op">&lt;=</span> WAIT_DATA<span class="op">;</span>    </span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<p>Note that state is set to WAIT_DATA, so that it waits for
<code>mem_rbusy</code> to go low before doing anything else.</p>
<p>OK, so now we have a large quantity of flash memory in which we can
install the code and run it from there. We can also install readonly
variables in there, like the string
<code>.asciz "Hello, world !\n"</code> in the previous example. And what
about local variables ? They are allocated on the stack, that resides in
the 6 kB of RAM that we have, so it will work. How does it know where
the stack is ? Remember, we have written <a
href="FIRMWARE/start.S">FIRMWARE/start.S</a>, that initializes
<code>sp</code> at the end of the RAM (<code>0x1800</code>) and it
suffices.</p>
<p>But how does it work for a program like that ?</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>     x <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>     printf<span class="op">(</span><span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span>x<span class="op">);</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>The global variable <code>x</code> has an initial value that needs to
be stored somewhere, so we need to put it in flash memory, but we are
modifying it after, so we need to put it in RAM, how is it possible ? In
fact, what we need is a mechanism for storing all the initial values of
the (initialized) global variables in flash memory and copy them to RAM
on startup. To do that, we will need a new linker script (that indicates
where to put the variables and where to put their initial values) and a
new <code>start.S</code> (that copies the initial values to the
variables). Let us see how to do that.</p>
<p>When you compile C code, the compiler inserts directives to indicate
where the different things go (sections). To take a look, generate
assembly from one of our C programs:</p>
<pre><code>$ cd FIRMWARE
$ make ST_NICCC.o
$ readelf -S ST_NICCC.o</code></pre>
<p>it will show you the different sections that are present in the
object file.</p>
<table>
<thead>
<tr class="header">
<th>section</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>text</td>
<td>executable code</td>
</tr>
<tr class="even">
<td>bss, sbss</td>
<td>uninitialized data</td>
</tr>
<tr class="odd">
<td>data, sdata</td>
<td>read-only data</td>
</tr>
<tr class="even">
<td>rodata</td>
<td>read-only data</td>
</tr>
</tbody>
</table>
<p>The section name (bss) for uninitialized data has an historic reason
that dates back to the 60’s (BSS: Block Started by Symbol is a
pseudo-instruction of an assembler for the IBM 704). Uninitialized and
initialized data sections come in two flavor, sbss and sdata is for
small uninitialized (resp) initialized) data.</p>
<p>In <code>readelf</code> output, there is also a <code>type</code>
field. <code>PROGBIT</code> means that some data needs to be loaded from
the file (for <code>text</code>, <code>data</code> and
<code>rodata</code>) segments. <code>NOBITS</code> means that no data
should be loaded (for <code>bss</code>). Then the <code>Addr</code>
indicates where the section will be mapped into memory (for a
<code>.o</code> file, it is always 0, but it is useful for a linked elf
executable, you can check using <code>readelf</code>). Then the
<code>Offs</code> field indicates the offset for the section’s data in
the <code>.o</code> file, and the <code>Size</code> field the number of
bytes in the section.</p>
<p>So what we have to do is writing a linker script that will say the
following things: - <code>text</code> sections go to the flash memory -
<code>bss</code> sections go to BRAM - <code>data</code> sections go to
BRAM, but have their initial values stored in the flash memory</p>
<p>For <code>text</code> and <code>bss</code>, we already know how to do
it. For <code>data</code>, linker scripts can specify a LMA (Load Memory
Address), that indicates where initial values need to be stored. In our
linker script, we will have something like:</p>
<pre><code>  MEMORY {
      FLASH (rx)  : ORIGIN = 0x00820000, LENGTH = 0x100000
      RAM   (rwx) : ORIGIN = 0x00000000, LENGTH = 0x1800  
  }
  SECTIONS {
  
    .data: AT(address_in_spi_flash) {
      *(.data*)          
      *(.sdata*)
    } &gt; RAM
    
    .text : {
      start_spiflash1.o(.text) 
      *(.text*) 
      *(.rodata*) 
      *(.srodata*)
    } &gt;FLASH
    
    .bss : {
      *(.bss*)
      *(.sbss*)
    } &gt;RAM
  }</code></pre>
<p>Each section indicates how to map sections read from object files to
sections in the executable (<code>.data</code>, <code>.text</code> and
<code>.bss</code>), and how to map these sections to the flash memory
and to the BRAM. For each section, some pattern matching rules indicate
which sections from the object files are concerned. For the
<code>.text</code> section, we make sure that the first section is the
text section of <code>start_spiflash1.o</code>, because our processor
jumps there on reset. Note also that we put the readonly data
(<code>.rodata</code> and <code>.srodata</code>) into the flash.</p>
<p>For the <code>.data</code> section, the <code>AT</code> keyword
indicates the LMA (Load Memory Address) where the linker will put the
initial values (an address in spi flash), and whenever a symbol in a
<code>data</code> or <code>sdata</code> section is referenced, the
linker will use its address in RAM.</p>
<p>But a question remains: how does the system know that it should copy
initialization data from the flash into BRAM ? How does it know at which
address ? How can we initialize uninitialized data (BSS) to zero ? In
fact we need to do it by hand, in the startup code
<code>start_spiflash1.S</code>, that looks like that:</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>.<span class="pp">equ</span> IO_BASE<span class="op">,</span> <span class="bn">0x400000</span>  </span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>.text</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>.global _start</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>.type _start<span class="op">,</span> <span class="fu">@f</span>unction</span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a><span class="fu">_start:</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a>.option push</span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>.option norelax</span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a>     li  gp<span class="op">,</span>IO_BASE</span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>.option pop</span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a>     li   <span class="kw">sp</span><span class="op">,</span><span class="bn">0x1800</span></span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a># zero<span class="op">-</span>init bss section<span class="op">:</span></span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a>     la a0<span class="op">,</span> _sbss</span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true" tabindex="-1"></a>     la a1<span class="op">,</span> _ebss</span>
<span id="cb140-18"><a href="#cb140-18" aria-hidden="true" tabindex="-1"></a>     bge a0<span class="op">,</span> a1<span class="op">,</span> end_init_bss</span>
<span id="cb140-19"><a href="#cb140-19" aria-hidden="true" tabindex="-1"></a><span class="fu">loop_init_bss:</span></span>
<span id="cb140-20"><a href="#cb140-20" aria-hidden="true" tabindex="-1"></a>     sw zero<span class="op">,</span> <span class="dv">0</span><span class="op">(</span>a0<span class="op">)</span></span>
<span id="cb140-21"><a href="#cb140-21" aria-hidden="true" tabindex="-1"></a>     addi a0<span class="op">,</span> a0<span class="op">,</span> <span class="dv">4</span></span>
<span id="cb140-22"><a href="#cb140-22" aria-hidden="true" tabindex="-1"></a>     blt a0<span class="op">,</span> a1<span class="op">,</span> loop_init_bss</span>
<span id="cb140-23"><a href="#cb140-23" aria-hidden="true" tabindex="-1"></a><span class="fu">end_init_bss:</span></span>
<span id="cb140-24"><a href="#cb140-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-25"><a href="#cb140-25" aria-hidden="true" tabindex="-1"></a># copy data section from SPI Flash to BRAM<span class="op">:</span></span>
<span id="cb140-26"><a href="#cb140-26" aria-hidden="true" tabindex="-1"></a>     la a0<span class="op">,</span> _sidata</span>
<span id="cb140-27"><a href="#cb140-27" aria-hidden="true" tabindex="-1"></a>     la a1<span class="op">,</span> _sdata</span>
<span id="cb140-28"><a href="#cb140-28" aria-hidden="true" tabindex="-1"></a>     la a2<span class="op">,</span> _edata</span>
<span id="cb140-29"><a href="#cb140-29" aria-hidden="true" tabindex="-1"></a>     bge a1<span class="op">,</span> a2<span class="op">,</span> end_init_data</span>
<span id="cb140-30"><a href="#cb140-30" aria-hidden="true" tabindex="-1"></a><span class="fu">loop_init_data:</span></span>
<span id="cb140-31"><a href="#cb140-31" aria-hidden="true" tabindex="-1"></a>     lw a3<span class="op">,</span> <span class="dv">0</span><span class="op">(</span>a0<span class="op">)</span></span>
<span id="cb140-32"><a href="#cb140-32" aria-hidden="true" tabindex="-1"></a>     sw a3<span class="op">,</span> <span class="dv">0</span><span class="op">(</span>a1<span class="op">)</span></span>
<span id="cb140-33"><a href="#cb140-33" aria-hidden="true" tabindex="-1"></a>     addi a0<span class="op">,</span> a0<span class="op">,</span> <span class="dv">4</span></span>
<span id="cb140-34"><a href="#cb140-34" aria-hidden="true" tabindex="-1"></a>     addi a1<span class="op">,</span> a1<span class="op">,</span> <span class="dv">4</span></span>
<span id="cb140-35"><a href="#cb140-35" aria-hidden="true" tabindex="-1"></a>     blt a1<span class="op">,</span> a2<span class="op">,</span> loop_init_data</span>
<span id="cb140-36"><a href="#cb140-36" aria-hidden="true" tabindex="-1"></a><span class="fu">end_init_data:</span></span>
<span id="cb140-37"><a href="#cb140-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-38"><a href="#cb140-38" aria-hidden="true" tabindex="-1"></a>     <span class="cf">call</span> main</span>
<span id="cb140-39"><a href="#cb140-39" aria-hidden="true" tabindex="-1"></a>     ebreak</span></code></pre></div>
<ul>
<li>The first thing that we do is initializing the stack pointer and the
general pointer <code>gp</code> (with the IO page address in our
case).</li>
<li>the first loop clears the memory between <code>_sbss</code> and
<code>_ebss</code>.</li>
<li>the second loop copies data from <code>_sidata</code> to
<code>_sdata</code> … <code>_edata</code></li>
<li>finally we call <code>main</code></li>
</ul>
<p>… but wait a minute, how do we know the values for
<code>_sbss</code>,<code>_ebss</code>,<code>_sidata</code>,<code>_sdata</code>,<code>_edata</code>
?</p>
<p>In fact, the linker script can generate them for us. Here is what the
<code>.data</code> section looks like:</p>
<pre><code>    .data : AT ( _sidata ) {
        . = ALIGN(4); 
        _sdata = .;
        *(.data*)          
        *(.sdata*)
        . = ALIGN(4);
        _edata = .;  
    } &gt; RAM</code></pre>
<p>where <code>.</code> denotes the current address. In addition, lines
like <code>. = ALIGN(4);</code> make sure that addresses remain aligned
on 4-bytes boundaries, since our initialization loops in
<code>start_spiflash1.S</code> depend on that.</p>
<p>The declaration for the <code>.text</code> section looks like:</p>
<pre><code>    .text : {
        . = ALIGN(4);
        start_spiflash1.o(.text)  
        *(.text*)                 
        . = ALIGN(4);
        *(.rodata*)              
        *(.srodata*)             
        _etext = .;              
        _sidata = _etext;        
    } &gt;FLASH</code></pre>
<p>note that it declares <code>_sidata</code> right at the end of the
text section, so that the <code>.data</code> section can put its
initialization data there.</p>
<p>OK, so let us try it with one of our examples:</p>
<pre><code>  $ cd FIRMWARE
  $ make mandel_C.spiflash1.prog
  $ cd ..
  $ ./terminal.sh</code></pre>
<p>Yes, it works, but <em>wait a minute</em>, it is significantly slower
than before. Can you guess why ?</p>
<p>Remember that the FLASH memory is a <em>serial</em> memory, wich
means that addresses are sent one bit at a time and the result is
obtained also one bit at a time (well, in fact two bits at a time for
both in our case), it is much slower than the BRAM that gets a 32-bits
value in one cycle. Can we do something ? Sure we can ! What about
putting some critical functions in BRAM ? To do that, we can change our
linker script as follows (result in <a
href="FIRMWARE/spiflash2.ld">FIRMWARE/spiflash2.ld</a>):</p>
<pre><code>    .data_and_fastcode : AT ( _sidata ) {
        . = ALIGN(4);
        _sdata = .;  
    
    /* Initialized data */
        *(.data*)          
        *(.sdata*)

    /* integer mul and div */
    */libgcc.a:muldi3.o(.text)
    */libgcc.a:div.o(.text)    

    putchar.o(.text)
    print.o(.text)  

    /* functions with attribute((section(&quot;.fastcode&quot;))) */  
    *(.fastcode*)      

        . = ALIGN(4);
        _edata = .;  
    } &gt; RAM</code></pre>
<p>By doing so, we indicate that some specific functions (integer
multiply and divide from libgcc and IO functions) should be put in fast
RAM, and that’s all we have to do ! The linker will put the code for
these functions in the same section as the initialization data for
initialized variables, and our runtime <code>start_spiflash1.S</code>
will copies them with the initialization data to RAM at startup, cool
!</p>
<p>Let us try it with our example:</p>
<pre><code>  $ cd FIRMWARE
  $ make mandel_C.spiflash2.prog
  $ cd ..
  $ ./terminal.sh</code></pre>
<p>Aaaah, much better !</p>
<p>Note also the line <code>*(.fastcode*)</code>: you can put your own
functions in BRAM, by indicating that they are in a
<code>fastcode</code> section. In C, you can do that as follows:</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a> <span class="dt">void</span> my_function<span class="op">(</span>my args <span class="op">...)</span> __attribute<span class="op">((</span>section<span class="op">(</span><span class="st">&quot;.fastcode&quot;</span><span class="op">)));</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">void</span> my_function<span class="op">(</span>my args <span class="op">...)</span> <span class="op">{</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a> <span class="op">}</span></span></code></pre></div>
<p><strong>Try this</strong> run the <code>ST_NICCC</code> demo
(<code>make ST_NICCC.spiflash2.prog</code>). Then uncomment the line in
<code>ST_NICCC.c</code> with the definition for
<code>RV32_FASTCODE</code> and re-run it.</p>
<p><img src="tinyraytracer_tty.png" /></p>
<p>Now we can run larger programs on our device: - <a
href="FIRMWARE/pi.c">FIRMWARE/pi.c</a> (by Fabrice Beillard, computes
the decimals of pi) - <a
href="FIRMWARE/tinyraytracer.c">FIRMWARE/tinyraytracer.c</a> (by Dmitry
Sokolov, raytracing)</p>
<p>Both of them use floating point numbers. For a RV32I core such as
ours, floating point numbers use routines implemented in
<code>libgcc</code>. As a consequence, executables are larger
(<code>pi</code> weights 17 kB and <code>tinyraytracer</code> weights 25
kB) and would have been impossible to run in 6 kB of RAM. The additional
memory offered by the SPI FLASH offers much more possibilities to our
device !</p>
<p>At this point, not only our device runs code compiled using standard
tools (gcc), but also it runs existing code, independently developped
(the mathematical routines in <code>libgcc</code>). It is quite exciting
to run existing binary code on a processor that you create on your own
!</p>
<h2 id="next-tutorial">Next tutorial</h2>
<p><a href="PIPELINE.md">Pipelining</a></p>
<h2 id="files-for-all-the-steps">Files for all the steps</h2>
<ul>
<li><a href="step1.v">step 1</a>: Blinker, too fast, can’t see
anything</li>
<li><a href="step2.v">step 2</a>: Blinker with clockworks</li>
<li><a href="step3.v">step 3</a>: Blinker that loads pattern from
ROM</li>
<li><a href="step4.v">step 4</a>: The instruction decoder</li>
<li><a href="step5.v">step 5</a>: The register bank and the state
machine</li>
<li><a href="step6.v">step 6</a>: The ALU</li>
<li><a href="step7.v">step 7</a>: Using the VERILOG assembler</li>
<li><a href="step8.v">step 8</a>: Jumps</li>
<li><a href="step9.v">step 9</a>: Branches</li>
<li><a href="step10.v">step 10</a>: LUI and AUIPC</li>
<li><a href="step11.v">step 11</a>: Memory in separate module</li>
<li><a href="step12.v">step 12</a>: Size optimization: the Incredible
Shrinking Core !</li>
<li><a href="step13.v">step 13</a>: Subroutines 1 (standard Risc-V
instruction set)</li>
<li><a href="step14.v">step 14</a>: Subroutines 2 (using Risc-V
pseudo-instructions)</li>
<li><a href="step15.v">step 15</a>: Load</li>
<li><a href="step16.v">step 16</a>: Store</li>
<li><a href="step17.v">step 17</a>: Memory-mapped devices</li>
<li><a href="step18.v">step 18</a>: Mandelbrot set</li>
<li>step 19: Faster simulation with Verilator</li>
<li><a href="step20.v">step 20</a>: Using the GNU toolchain to compile
assembly programs</li>
<li>step 21: Using the GNU toolchain to compile C programs</li>
<li><a href="step22.v">step 22</a>: More memory ! Using the SPI
Flash</li>
<li><a href="step23.v">step 23</a>: Running programs from the SPI Flash,
first steps</li>
<li><a href="step24.v">step 24</a>: Running programs from the SPI Flash,
better linker script</li>
</ul>
<p><em>WIP</em></p>
<ul>
<li>step 25: More devices (LED matrix, OLED screen…)</li>
</ul>
</body>
</html>
